(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{415:function(t,i,e){"use strict";function n(t,i,e){return t[0]=i[0]-e[0],t[1]=i[1]-e[1],t}function r(t,i){return Math.sqrt(t*t+i*i)}function s(t){const i=r(t[0],t[1]);t[0]/=i,t[1]/=i}function x(t,i){return r(t[0]-i[0],t[1]-i[1])}function h(t){return"function"==typeof t}function o(t){return 1/Math.max(t,1)}e.d(i,"a",(function(){return x})),e.d(i,"b",(function(){return o})),e.d(i,"c",(function(){return h})),e.d(i,"d",(function(){return s})),e.d(i,"e",(function(){return n}))},492:function(t,i,e){"use strict";e.d(i,"a",(function(){return o})),e.d(i,"b",(function(){return h}));var n=e(396),r=e(448),s=e(530);class x{constructor(t,i,e){this.ratio=t,this.x=i,this.y=e}}class h{constructor(t,i,e,r=8,s=8){this.lines=[],this.starts=[],this.pixelRatio=r,this.pixelMargin=s,this.tileSize=n.F*r,this.dz=t,this.yPos=i,this.xPos=e}setExtent(t){this.finalRatio=this.tileSize/t*(1<<this.dz);let i=this.pixelRatio*this.pixelMargin;i/=this.finalRatio;const e=t>>this.dz;i>e&&(i=e),this.margin=i,this.xmin=e*this.xPos-i,this.ymin=e*this.yPos-i,this.xmax=this.xmin+e+2*i,this.ymax=this.ymin+e+2*i}reset(t){this.type=t,this.lines=[],this.starts=[],this.line=null,this.start=0}moveTo(t,i){this._pushLine(),this._prevIsIn=this._isIn(t,i),this._moveTo(t,i,this._prevIsIn),this._prevPt=new s.a(t,i),this._firstPt=new s.a(t,i),this._dist=0}lineTo(t,i){const e=this._isIn(t,i),n=new s.a(t,i),r=s.a.distance(this._prevPt,n);let h,o,l,u,y,a,c,d;if(e)this._prevIsIn?this._lineTo(t,i,!0):(h=this._prevPt,o=n,l=this._intersect(o,h),this.start=this._dist+r*(1-this._r),this._lineTo(l.x,l.y,!0),this._lineTo(o.x,o.y,!0));else if(this._prevIsIn)o=this._prevPt,h=n,l=this._intersect(o,h),this._lineTo(l.x,l.y,!0),this._lineTo(h.x,h.y,!1);else{const t=this._prevPt,i=n;if(t.x<=this.xmin&&i.x<=this.xmin||t.x>=this.xmax&&i.x>=this.xmax||t.y<=this.ymin&&i.y<=this.ymin||t.y>=this.ymax&&i.y>=this.ymax)this._lineTo(i.x,i.y,!1);else{const e=[];if((t.x<this.xmin&&i.x>this.xmin||t.x>this.xmin&&i.x<this.xmin)&&(u=(this.xmin-t.x)/(i.x-t.x),d=t.y+u*(i.y-t.y),d<=this.ymin?a=!1:d>=this.ymax?a=!0:e.push(new x(u,this.xmin,d))),(t.x<this.xmax&&i.x>this.xmax||t.x>this.xmax&&i.x<this.xmax)&&(u=(this.xmax-t.x)/(i.x-t.x),d=t.y+u*(i.y-t.y),d<=this.ymin?a=!1:d>=this.ymax?a=!0:e.push(new x(u,this.xmax,d))),(t.y<this.ymin&&i.y>this.ymin||t.y>this.ymin&&i.y<this.ymin)&&(u=(this.ymin-t.y)/(i.y-t.y),c=t.x+u*(i.x-t.x),c<=this.xmin?y=!1:c>=this.xmax?y=!0:e.push(new x(u,c,this.ymin))),(t.y<this.ymax&&i.y>this.ymax||t.y>this.ymax&&i.y<this.ymax)&&(u=(this.ymax-t.y)/(i.y-t.y),c=t.x+u*(i.x-t.x),c<=this.xmin?y=!1:c>=this.xmax?y=!0:e.push(new x(u,c,this.ymax))),0===e.length)y?a?this._lineTo(this.xmax,this.ymax,!0):this._lineTo(this.xmax,this.ymin,!0):a?this._lineTo(this.xmin,this.ymax,!0):this._lineTo(this.xmin,this.ymin,!0);else if(e.length>1&&e[0].ratio>e[1].ratio)this.start=this._dist+r*e[1].ratio,this._lineTo(e[1].x,e[1].y,!0),this._lineTo(e[0].x,e[0].y,!0);else{this.start=this._dist+r*e[0].ratio;for(let t=0;t<e.length;t++)this._lineTo(e[t].x,e[t].y,!0)}this._lineTo(i.x,i.y,!1)}}this._dist+=r,this._prevIsIn=e,this._prevPt=n}close(){if(this.line.length>2){const t=this._firstPt,i=this._prevPt;t.x===i.x&&t.y===i.y||this.lineTo(t.x,t.y);const e=this.line;let n=e.length;for(;n>=4&&(e[0].x===e[1].x&&e[0].x===e[n-2].x||e[0].y===e[1].y&&e[0].y===e[n-2].y);)e.pop(),e[0].x=e[n-2].x,e[0].y=e[n-2].y,--n}}result(t=!0){return this._pushLine(),0===this.lines.length?null:(3===this.type&&t&&l.simplify(this.tileSize,this.margin*this.finalRatio,this.lines),this.lines)}resultWithStarts(){if(2!==this.type)throw new Error("Only valid for lines");this._pushLine();const t=this.lines,i=t.length;if(0===i)return null;const e=[];for(let n=0;n<i;n++)e.push({line:t[n],start:this.starts[n]||0});return e}_isIn(t,i){return t>=this.xmin&&t<=this.xmax&&i>=this.ymin&&i<=this.ymax}_intersect(t,i){let e,n,r;if(i.x>=this.xmin&&i.x<=this.xmax)n=i.y<=this.ymin?this.ymin:this.ymax,r=(n-t.y)/(i.y-t.y),e=t.x+r*(i.x-t.x);else if(i.y>=this.ymin&&i.y<=this.ymax)e=i.x<=this.xmin?this.xmin:this.xmax,r=(e-t.x)/(i.x-t.x),n=t.y+r*(i.y-t.y);else{n=i.y<=this.ymin?this.ymin:this.ymax,e=i.x<=this.xmin?this.xmin:this.xmax;const s=(e-t.x)/(i.x-t.x),x=(n-t.y)/(i.y-t.y);s<x?(r=s,n=t.y+s*(i.y-t.y)):(r=x,e=t.x+x*(i.x-t.x))}return this._r=r,new s.a(e,n)}_pushLine(){this.line&&(1===this.type?this.line.length>0&&(this.lines.push(this.line),this.starts.push(this.start)):2===this.type?this.line.length>1&&(this.lines.push(this.line),this.starts.push(this.start)):3===this.type&&this.line.length>3&&(this.lines.push(this.line),this.starts.push(this.start))),this.line=[],this.start=0}_moveTo(t,i,e){3!==this.type?e&&(t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),i=Math.round((i-(this.ymin+this.margin))*this.finalRatio),this.line.push(new s.a(t,i))):(e||(t<this.xmin&&(t=this.xmin),t>this.xmax&&(t=this.xmax),i<this.ymin&&(i=this.ymin),i>this.ymax&&(i=this.ymax)),t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),i=Math.round((i-(this.ymin+this.margin))*this.finalRatio),this.line.push(new s.a(t,i)),this._is_h=!1,this._is_v=!1)}_lineTo(t,i,e){let n,r;if(3!==this.type)if(e){if(t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),i=Math.round((i-(this.ymin+this.margin))*this.finalRatio),this.line.length>0&&(n=this.line[this.line.length-1],n.equals(t,i)))return;this.line.push(new s.a(t,i))}else this.line&&this.line.length>0&&this._pushLine();else if(e||(t<this.xmin&&(t=this.xmin),t>this.xmax&&(t=this.xmax),i<this.ymin&&(i=this.ymin),i>this.ymax&&(i=this.ymax)),t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),i=Math.round((i-(this.ymin+this.margin))*this.finalRatio),this.line&&this.line.length>0){n=this.line[this.line.length-1];const e=n.x===t,x=n.y===i;if(e&&x)return;this._is_h&&e||this._is_v&&x?(n.x=t,n.y=i,r=this.line[this.line.length-2],r.x===t&&r.y===i?(this.line.pop(),this.line.length<=1?(this._is_h=!1,this._is_v=!1):(r=this.line[this.line.length-2],this._is_h=r.x===t,this._is_v=r.y===i)):(this._is_h=r.x===t,this._is_v=r.y===i)):(this.line.push(new s.a(t,i)),this._is_h=e,this._is_v=x)}else this.line.push(new s.a(t,i))}}class o{setExtent(t){this._ratio=4096===t?1:4096/t}reset(t){this.type=t,this.lines=[],this.line=null}moveTo(t,i){this.line&&this.lines.push(this.line),this.line=[];const e=this._ratio;this.line.push(new s.a(Math.round(t*e),Math.round(i*e)))}lineTo(t,i){const e=this._ratio;this.line.push(new s.a(Math.round(t*e),Math.round(i*e)))}close(){const t=this.line;t&&!t[0].isEqual(t[t.length-1])&&t.push(t[0])}result(){return this.line&&this.lines.push(this.line),0===this.lines.length?null:(3===this.type&&1!==this._ratio&&l.simplify(4096,64,this.lines),this.lines)}}class l{static simplify(t,i,e){if(!e)return;const n=-i,r=t+i,s=-i,x=t+i,h=[],o=[],u=e.length;for(let t=0;t<u;++t){const i=e[t];if(!i||i.length<2)continue;let l,u=i[0];const y=i.length;for(let e=1;e<y;++e)l=i[e],u.x===l.x&&(u.x<=n&&(u.y>l.y?(h.push(t),h.push(e),h.push(0),h.push(-1)):(o.push(t),o.push(e),o.push(0),o.push(-1))),u.x>=r&&(u.y<l.y?(h.push(t),h.push(e),h.push(1),h.push(-1)):(o.push(t),o.push(e),o.push(1),o.push(-1)))),u.y===l.y&&(u.y<=s&&(u.x<l.x?(h.push(t),h.push(e),h.push(2),h.push(-1)):(o.push(t),o.push(e),o.push(2),o.push(-1))),u.y>=x&&(u.x>l.x?(h.push(t),h.push(e),h.push(3),h.push(-1)):(o.push(t),o.push(e),o.push(3),o.push(-1)))),u=l}if(0===h.length||0===o.length)return;l.fillParent(e,o,h),l.fillParent(e,h,o);const y=[];l.calcDeltas(y,o,h),l.calcDeltas(y,h,o),l.addDeltas(y,e)}static fillParent(t,i,e){const n=e.length,s=i.length;for(let x=0;x<s;x+=4){const s=i[x],h=i[x+1],o=i[x+2],l=t[s][h-1],u=t[s][h];let y=8092,a=-1;for(let i=0;i<n;i+=4){if(e[i+2]!==o)continue;const n=e[i],s=e[i+1],x=t[n][s-1],h=t[n][s];switch(o){case 0:case 1:if(Object(r.a)(l.y,x.y,h.y)&&Object(r.a)(u.y,x.y,h.y)){const t=Math.abs(h.y-x.y);t<y&&(y=t,a=i)}break;case 2:case 3:if(Object(r.a)(l.x,x.x,h.x)&&Object(r.a)(u.x,x.x,h.x)){const t=Math.abs(h.x-x.x);t<y&&(y=t,a=i)}}}i[x+3]=a}}static calcDeltas(t,i,e){const n=i.length;for(let r=0;r<n;r+=4){const n=[],s=l.calcDelta(r,i,e,n);t.push(i[r]),t.push(i[r+1]),t.push(i[r+2]),t.push(s)}}static calcDelta(t,i,e,n){const r=i[t+3];if(-1===r)return 0;const s=n.length;return s>1&&n[s-2]===r?0:(n.push(r),l.calcDelta(r,e,i,n)+1)}static addDeltas(t,i){const e=t.length;let n=0;for(let i=0;i<e;i+=4){const e=t[i+3];e>n&&(n=e)}for(let r=0;r<e;r+=4){const e=i[t[r]],s=t[r+1],x=n-t[r+3];switch(t[r+2]){case 0:e[s-1].x-=x,e[s].x-=x,1===s&&(e[e.length-1].x-=x),s===e.length-1&&(e[0].x-=x);break;case 1:e[s-1].x+=x,e[s].x+=x,1===s&&(e[e.length-1].x+=x),s===e.length-1&&(e[0].x+=x);break;case 2:e[s-1].y-=x,e[s].y-=x,1===s&&(e[e.length-1].y-=x),s===e.length-1&&(e[0].y-=x);break;case 3:e[s-1].y+=x,e[s].y+=x,1===s&&(e[e.length-1].y+=x),s===e.length-1&&(e[0].y+=x)}}}}},530:function(t,i,e){"use strict";e.d(i,"a",(function(){return n}));class n{constructor(t,i){this.x=t,this.y=i}clone(){return new n(this.x,this.y)}equals(t,i){return t===this.x&&i===this.y}isEqual(t){return t.x===this.x&&t.y===this.y}setCoords(t,i){this.x=t,this.y=i}normalize(){const t=this.x,i=this.y,e=Math.sqrt(t*t+i*i);this.x/=e,this.y/=e}rightPerpendicular(){const t=this.x;this.x=this.y,this.y=-t}move(t,i){this.x+=t,this.y+=i}assign(t){this.x=t.x,this.y=t.y}assignAdd(t,i){this.x=t.x+i.x,this.y=t.y+i.y}assignSub(t,i){this.x=t.x-i.x,this.y=t.y-i.y}rotate(t,i){const e=this.x,n=this.y;this.x=e*t-n*i,this.y=e*i+n*t}scale(t){this.x*=t,this.y*=t}length(){const t=this.x,i=this.y;return Math.sqrt(t*t+i*i)}static distance(t,i){const e=i.x-t.x,n=i.y-t.y;return Math.sqrt(e*e+n*n)}static add(t,i){return new n(t.x+i.x,t.y+i.y)}static sub(t,i){return new n(t.x-i.x,t.y-i.y)}}},546:function(t,i,e){"use strict";e.d(i,"a",(function(){return v})),e.d(i,"b",(function(){return s})),e.d(i,"c",(function(){return x})),e.d(i,"d",(function(){return r}));var n=e(415);function r(t,i,e){o.trackDistance=null!=i.trackDistance&&i.trackDistance,o.wrapDistance=null!=i.wrapDistance?i.wrapDistance:65535,o.thin=null!=i.thin&&i.thin,o.initialDistance=null!=i.initialDistance?i.initialDistance:0,o.enableOuterBisectorSplit=null!=i.enableOuterBisectorSplit&&i.enableOuterBisectorSplit,o.outerBisectorAutoSplitThreshold=null!=i.outerBisectorAutoSplitThreshold?i.outerBisectorAutoSplitThreshold:0,o.enableInnerBisectorSplit=null!=i.enableOuterBisectorSplit&&i.enableOuterBisectorSplit,o.innerBisectorAutoSplitThreshold=null!=i.innerBisectorAutoSplitThreshold?i.innerBisectorAutoSplitThreshold:0,h=t,l=e,p=0,u=0,y=0,a=!1,c=null,d=null,m.currentVertex.x=null,m.currentVertex.y=null,m.distance=o.initialDistance;const n=h[0],r=h[h.length-1];m.canSplit=!1,m.closed=n.x===r.x&&n.y===r.y,h.length<2||2===h.length&&m.closed||(o.thin?o.trackDistance?function(){for(g(),b(),E(1);u-y>o.wrapDistance||p<h.length;)g(),b(),E(2),l.bridge(m),m.leftExit0=m.rightExit0,m.leftExit2=m.rightExit2}():function(){for(;p<h.length;){if(p>0&&(m.inbound.x=m.outbound.x,m.inbound.y=m.outbound.y),p<h.length-1){m.outbound.x=h[p+1].x-h[p].x,m.outbound.y=h[p+1].y-h[p].y;const t=Math.sqrt(m.outbound.x*m.outbound.x+m.outbound.y*m.outbound.y);m.distance+=t,m.outbound.x/=t,m.outbound.y/=t}else m.outbound.x=m.inbound.x,m.outbound.y=m.inbound.y;0===p&&(m.inbound.x=m.outbound.x,m.inbound.y=m.outbound.y),m.currentVertex.x=h[p].x,m.currentVertex.y=h[p].y,m.prevNormal.x=-m.inbound.y,m.prevNormal.y=m.inbound.x,m.nextNormal.x=-m.outbound.y,m.nextNormal.y=m.outbound.x,0===p?(l.vertex(m),m.leftEntry0=m.entry0,m.leftEntry2=m.entry2,m.leftExit0=m.exit0,m.leftExit2=m.exit2):(l.vertex(m),m.rightEntry0=m.entry0,m.rightEntry2=m.entry2,m.rightExit0=m.exit0,m.rightExit2=m.exit2,l.bridge(m),m.leftExit0=m.rightExit0,m.leftExit2=m.rightExit2),++p}}():o.enableOuterBisectorSplit||o.outerBisectorAutoSplitThreshold>0||o.enableInnerBisectorSplit||o.innerBisectorAutoSplitThreshold>0?(m.canSplit=!0,function(){for(g(),f(),m.splitInner=m.gapInner=m.splitOuter=m.gapOuter=!1,V(1),m.closure0=m.leftEntry0,m.closure1=m.leftEntry1,m.closure2=m.leftEntry2;u-y>o.wrapDistance||p<h.length-1||p<h.length&&(!m.closed||o.trackDistance);)g(),f(),m.splitInner=m.gapInner=m.splitOuter=m.gapOuter=!1,V(2),l.bridge(m),m.leftExit0=m.rightExit0,m.leftExit1=m.rightExit1,m.leftExit2=m.rightExit2;m.closed&&!o.trackDistance&&(m.rightEntry0=m.closure0,m.rightEntry1=m.closure1,m.rightEntry2=m.closure2,l.bridge(m),m.leftExit0=m.rightExit0,m.leftExit1=m.rightExit1,m.leftExit2=m.rightExit2)}()):function(){for(g(),f(),V(1),m.closure0=m.leftEntry0,m.closure1=m.leftEntry1,m.closure2=m.leftEntry2;u-y>o.wrapDistance||p<h.length-1||p<h.length&&(!m.closed||o.trackDistance);)g(),f(),V(2),l.bridge(m),m.leftExit0=m.rightExit0,m.leftExit1=m.rightExit1,m.leftExit2=m.rightExit2;m.closed&&!o.trackDistance&&(m.rightEntry0=m.closure0,m.rightEntry1=m.closure1,m.rightEntry2=m.closure2,l.bridge(m),m.leftExit0=m.rightExit0,m.leftExit1=m.rightExit1,m.leftExit2=m.rightExit2)}())}function s(){h=null,l=null}function x(){if(m.cosine<o.innerBisectorAutoSplitThreshold){m.splitInner=!0,m.gapInner=!0;const t=Math.max(o.innerBisectorAutoSplitThreshold,m.cosine),i=Math.sqrt(1-t*t)/t;m.leftInner.x=m.nextNormal.x+m.sign*i*m.outbound.x,m.leftInner.y=m.nextNormal.y+m.sign*i*m.outbound.y,m.rightInner.x=m.prevNormal.x-m.sign*i*m.inbound.x,m.rightInner.y=m.prevNormal.y-m.sign*i*m.inbound.y}else o.enableInnerBisectorSplit&&(m.splitInner=!0,m.gapInner=!1,m.leftInner.x=m.rightInner.x=m.bisector.x/m.cosine,m.leftInner.y=m.rightInner.y=m.bisector.y/m.cosine);if(m.cosine<o.outerBisectorAutoSplitThreshold){m.splitOuter=!0,m.gapOuter=!0;const t=Math.max(o.outerBisectorAutoSplitThreshold,m.cosine),i=Math.sqrt(1-t*t)/t;m.leftOuter.x=m.prevNormal.x-m.sign*i*m.inbound.x,m.leftOuter.y=m.prevNormal.y-m.sign*i*m.inbound.y,m.rightOuter.x=m.nextNormal.x+m.sign*i*m.outbound.x,m.rightOuter.y=m.nextNormal.y+m.sign*i*m.outbound.y}else o.enableOuterBisectorSplit&&(m.splitOuter=!0,m.gapOuter=!1,m.leftOuter.x=m.rightOuter.x=m.bisector.x/m.cosine,m.leftOuter.y=m.rightOuter.y=m.bisector.y/m.cosine)}let h;const o={};let l,u,y,a,c,d,p=void 0;const m=new class{constructor(){this.closed=void 0,this.isFirstVertex=void 0,this.isLastVertex=void 0,this.isCap=void 0,this.currentVertex={x:void 0,y:void 0},this.inbound={x:void 0,y:void 0},this.outbound={x:void 0,y:void 0},this.prevNormal={x:void 0,y:void 0},this.nextNormal={x:void 0,y:void 0},this.bisector={x:void 0,y:void 0},this.leftInner={x:void 0,y:void 0},this.rightInner={x:void 0,y:void 0},this.leftOuter={x:void 0,y:void 0},this.rightOuter={x:void 0,y:void 0}}};function g(){if(a)return m.distance=0,m.isCap=m.isFirstVertex=m.isLastVertex=!1,void(a=!1);if(0===u)if(m.isFirstVertex=0===p,d=h[p],0===p){if(u=0,m.closed){m.inbound.x=d.x-h[h.length-2].x,m.inbound.y=d.y-h[h.length-2].y;const t=Math.sqrt(m.inbound.x*m.inbound.x+m.inbound.y*m.inbound.y);m.inbound.x/=t,m.inbound.y/=t}}else m.inbound.x=d.x-c.x,m.inbound.y=d.y-c.y,u=Math.sqrt(m.inbound.x*m.inbound.x+m.inbound.y*m.inbound.y),m.inbound.x/=u,m.inbound.y/=u;if(m.distance+u-y<=o.wrapDistance){if(p<h.length-1){m.outbound.x=h[p+1].x-d.x,m.outbound.y=h[p+1].y-d.y;const t=Math.sqrt(m.outbound.x*m.outbound.x+m.outbound.y*m.outbound.y);m.outbound.x/=t,m.outbound.y/=t}else if(m.closed){m.outbound.x=h[1].x-d.x,m.outbound.y=h[1].y-d.y;const t=Math.sqrt(m.outbound.x*m.outbound.x+m.outbound.y*m.outbound.y);m.outbound.x/=t,m.outbound.y/=t}else m.outbound.x=m.inbound.x,m.outbound.y=m.inbound.y;return 0!==p||m.closed||(m.inbound.x=m.outbound.x,m.inbound.y=m.outbound.y),++p,m.isLastVertex=p===h.length,m.isCap=!m.closed&&(m.isFirstVertex||m.isLastVertex),m.distance+=u-y,u=0,y=0,a=m.distance+u-y===o.wrapDistance,m.currentVertex.x=d.x,m.currentVertex.y=d.y,c=d,void(d=null)}m.outbound.x=m.inbound.x,m.outbound.y=m.inbound.y,y+=o.wrapDistance-m.distance,m.distance=o.wrapDistance,a=!0;const t=y/u;m.currentVertex.x=(1-t)*c.x+t*d.x,m.currentVertex.y=(1-t)*c.y+t*d.y}function b(){m.prevNormal.x=-m.inbound.y,m.prevNormal.y=m.inbound.x,m.nextNormal.x=-m.outbound.y,m.nextNormal.y=m.outbound.x}function f(){b(),m.bisector.x=m.prevNormal.x+m.nextNormal.x,m.bisector.y=m.prevNormal.y+m.nextNormal.y;const t=Math.sqrt(m.bisector.x*m.bisector.x+m.bisector.y*m.bisector.y);if(t<.001)return m.bisector.x=void 0,m.bisector.y=void 0,m.cosine=0,void(m.sign=void 0);m.bisector.x/=t,m.bisector.y/=t,m.cosine=m.bisector.x*m.nextNormal.x+m.bisector.y*m.nextNormal.y,m.sign=m.prevNormal.x*m.nextNormal.y-m.prevNormal.y*m.nextNormal.x>=0?1:-1}function V(t){l.vertex(m),1===t?(m.leftEntry0=m.entry0,m.leftEntry1=m.entry1,m.leftEntry2=m.entry2,m.leftExit0=m.exit0,m.leftExit1=m.exit1,m.leftExit2=m.exit2):2===t&&(m.rightEntry0=m.entry0,m.rightEntry1=m.entry1,m.rightEntry2=m.entry2,m.rightExit0=m.exit0,m.rightExit1=m.exit1,m.rightExit2=m.exit2)}function E(t){l.vertex(m),1===t?(m.leftEntry0=m.entry0,m.leftEntry2=m.entry2,m.leftExit0=m.exit0,m.leftExit2=m.exit2):2===t&&(m.rightEntry0=m.entry0,m.rightEntry2=m.entry2,m.rightExit0=m.exit0,m.rightExit2=m.exit2)}class v{constructor(t,i){this.writeVertex=t,this.writeTriangle=i,this.capType=0,this.joinType=2,this.miterLimitCosine=Object(n.b)(2),this.roundLimitCosine=Math.cos(23*Math.PI/180),this.almostParallelCosine=.97,this.radsPerSlice=.8,this.textured=!1,this.joinOnUTurn=!1}vertex(t){const i=2===this.joinType?this.miterLimitCosine:this.roundLimitCosine,e=t.isCap&&0!==this.capType;let n=!1;t.cosine>this.almostParallelCosine?(t.exit0=t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.bisector.x/t.cosine,t.bisector.y/t.cosine,0,-1,t.distance),t.exit2=t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.bisector.x/t.cosine,-t.bisector.y/t.cosine,0,1,t.distance)):t.cosine<1-this.almostParallelCosine?(n=!t.isCap&&this.joinOnUTurn,t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.prevNormal.x,t.prevNormal.y,0,-1,t.distance),t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.prevNormal.x,-t.prevNormal.y,0,1,t.distance),t.exit0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.nextNormal.x,t.nextNormal.y,0,-1,t.distance),t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.nextNormal.x,-t.nextNormal.y,0,1,t.distance)):t.canSplit?(x(),t.sign>0?(t.splitInner?(t.exit0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.outbound.x,t.outbound.y,t.leftInner.x,t.leftInner.y,0,-1,t.distance),t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,t.rightInner.x,t.rightInner.y,0,-1,t.distance)):t.exit0=t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,t.bisector.x/t.cosine,t.bisector.y/t.cosine,0,-1,t.distance),t.cosine<i?(n=!t.isCap,t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.prevNormal.x,-t.prevNormal.y,0,1,t.distance),t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.nextNormal.x,-t.nextNormal.y,0,1,t.distance)):t.splitOuter?(n=n||t.gapOuter,t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,-t.leftOuter.x,-t.leftOuter.y,0,1,t.distance),t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.outbound.x,t.outbound.y,-t.rightOuter.x,-t.rightOuter.y,0,1,t.distance)):t.entry2=t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.bisector.x/t.cosine,-t.bisector.y/t.cosine,0,1,t.distance)):(t.splitInner?(t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.outbound.x,t.outbound.y,-t.leftInner.x,-t.leftInner.y,0,1,t.distance),t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,-t.rightInner.x,-t.rightInner.y,0,1,t.distance)):t.exit2=t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.bisector.x/t.cosine,-t.bisector.y/t.cosine,0,1,t.distance),t.cosine<i?(n=!t.isCap,t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.prevNormal.x,t.prevNormal.y,0,-1,t.distance),t.exit0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.nextNormal.x,t.nextNormal.y,0,-1,t.distance)):t.splitOuter?(n=n||t.gapOuter,t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,t.leftOuter.x,t.leftOuter.y,0,-1,t.distance),t.exit0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.outbound.x,t.outbound.y,t.rightOuter.x,t.rightOuter.y,0,-1,t.distance)):t.exit0=t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.bisector.x/t.cosine,t.bisector.y/t.cosine,0,-1,t.distance))):t.sign>0?(t.exit0=t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,t.bisector.x/t.cosine,t.bisector.y/t.cosine,0,-1,t.distance),t.cosine<i?(n=!t.isCap,t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.prevNormal.x,-t.prevNormal.y,0,1,t.distance),t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.nextNormal.x,-t.nextNormal.y,0,1,t.distance)):t.entry2=t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.bisector.x/t.cosine,-t.bisector.y/t.cosine,0,1,t.distance)):(t.exit2=t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.bisector.x/t.cosine,-t.bisector.y/t.cosine,0,1,t.distance),t.cosine<i?(n=!t.isCap,t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.prevNormal.x,t.prevNormal.y,0,-1,t.distance),t.exit0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.nextNormal.x,t.nextNormal.y,0,-1,t.distance)):t.exit0=t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.bisector.x/t.cosine,t.bisector.y/t.cosine,0,-1,t.distance));const r=t.canSplit&&(t.splitInner||t.splitOuter);let s;if(s=t.entry1=t.exit1=r||n||e?this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,0,0,0,0,t.distance):null,n&&1!==this.joinType)this.writeTriangle(s,t.sign>0?t.exit2:t.entry0,t.sign>0?t.entry2:t.exit0);else if(e&&1===this.capType||n&&1===this.joinType){let i,e,n,r,x,h;if(t.isCap){const s=Math.PI;x=Math.ceil(s/this.radsPerSlice),h=s/x,t.isFirstVertex?(i=t.prevNormal.x,e=t.prevNormal.y,n=t.entry0,r=t.entry2):t.isLastVertex&&(i=-t.nextNormal.x,e=-t.nextNormal.y,n=t.exit2,r=t.exit0)}else{const s=2*Math.acos(t.cosine);x=Math.ceil(s/this.radsPerSlice),h=s/x,i=t.sign>0?-t.prevNormal.x:t.nextNormal.x,e=t.sign>0?-t.prevNormal.y:t.nextNormal.y,n=t.sign>0?t.entry2:t.exit0,r=t.sign>0?t.exit2:t.entry0}const o=Math.cos(h),l=Math.sin(h),u=l*i+o*e;let y,a;i=o*i-l*e,e=u;for(let h=0;h<x;++h){if(y=a,h<x-1)if(t.isCap){const n=t.isFirstVertex?-1:1;a=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,i,e,n,0,t.distance)}else a=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,i,e,0,t.sign,t.distance);this.writeTriangle(0===h?n:y,s,h===x-1?r:a);const u=l*i+o*e;i=o*i-l*e,e=u}}else if(e&&2===this.capType){const i=t.isFirstVertex?1:-1;let e,n;this.textured?(e=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.prevNormal.x-i*t.inbound.x,t.prevNormal.y-i*t.inbound.y,-i,-1,t.distance),n=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.prevNormal.x-i*t.inbound.x,-t.prevNormal.y-i*t.inbound.y,-i,1,t.distance)):(e=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.prevNormal.x-i*t.inbound.x,t.prevNormal.y-i*t.inbound.y,0,-1,t.distance),n=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.prevNormal.x-i*t.inbound.x,-t.prevNormal.y-i*t.inbound.y,0,1,t.distance)),i>0?(this.writeTriangle(s,t.entry2,n),this.writeTriangle(s,n,e),this.writeTriangle(s,e,t.entry0)):(this.writeTriangle(s,n,t.exit2),this.writeTriangle(s,e,n),this.writeTriangle(s,t.exit0,e))}}bridge(t){this.writeTriangle(t.leftExit0,t.rightEntry0,null!=t.leftExit1?t.leftExit1:t.leftExit2),this.writeTriangle(t.rightEntry0,null!=t.rightEntry1?t.rightEntry1:t.rightEntry2,null!=t.leftExit1?t.leftExit1:t.leftExit2),null!=t.leftExit1&&null!=t.rightEntry1?(this.writeTriangle(t.leftExit1,t.rightEntry1,t.leftExit2),this.writeTriangle(t.rightEntry1,t.rightEntry2,t.leftExit2)):null!=t.leftExit1?this.writeTriangle(t.leftExit1,t.rightEntry2,t.leftExit2):null!=t.rightEntry1&&this.writeTriangle(t.rightEntry1,t.rightEntry2,t.leftExit2)}}}}]);
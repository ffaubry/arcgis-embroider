(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{1005:function(e,t,s){"use strict";s.r(t);var i=s(0),r=s(4),o=(s(9),s(5),s(6),s(1),s(2)),n=(s(3),s(10),s(11),s(259)),a=s(513),l=s(544),u=s(540),c=s(730),d=s(7),h=s(397),f=s(549),p=s(555);class y extends p.a{constructor(e,t,s){super(e),this._pointToCallbacks=new Map,this._layer=s,this._layerView=t}renderChildren(e){this.hasAnimation&&e.painter.effects.integrate.draw(e,e.attributeView),super.renderChildren(e)}hitTest(e,t){const s=[e,t],i=Object(d.g)();return this._pointToCallbacks.set(s,i),this.requestRender(),i.promise}doRender(e){const{minScale:t,maxScale:s}=this._layer,i=e.state.scale;i<=(t||1/0)&&i>=s&&super.doRender(e)}get hasAnimation(){return this.hasLabels}get hasLabels(){const e=this._layer.featureReduction,t=e&&"cluster"===e.type&&e.labelsVisible&&e.labelingInfo&&e.labelingInfo.length;return this._layer.labelingInfo&&this._layer.labelingInfo.length&&this._layer.labelsVisible||!!t}get labelsVisible(){return this._layer.labelsVisible}prepareRenderPasses(e){const t=e.registerRenderPass({name:"label",brushes:[f.a.label],target:()=>this.hasLabels?this.children:null,drawPhase:h.c.LABEL|h.c.LABEL_ALPHA}),s=e.registerRenderPass({name:"geometry",brushes:[f.a.fill,f.a.line,f.a.marker,f.a.text],target:()=>this.children,effects:[{apply:e.effects.highlight,enable:()=>!!this._layerView.hasHighlight()},{apply:e.effects.hittest,enable:()=>!!this._pointToCallbacks.size,args:()=>this._pointToCallbacks}]});return[...super.prepareRenderPasses(e),s,t]}}let b=class extends c.a{install(e){const t=new y(this.tileInfoView,this.layerView,this.layer);this.featuresView=t,e.addChild(t)}uninstall(e){e.removeChild(this.featuresView),this.featuresView.destroy()}hitTest(e,t){return this.featuresView.hitTest(e,t)}supportsRenderer(e){return null!=e&&-1!==["simple","class-breaks","unique-value","dot-density","dictionary"].indexOf(e.type)}onConfigUpdate(e){let t=null;if("visualVariables"in e){const s=(Object(l.a)(e).visualVariables||[]).map(e=>{const t=e.clone();return"normalizationField"in e&&(t.normalizationField=null),e.valueExpression&&"$view.scale"!==e.valueExpression&&(t.valueExpression=null,t.field="nop"),t});t=Object(u.a)(s)}this.featuresView.setRendererInfo(e,t,this.layerView.effects)}onTileData(e){const t=this.tiles.get(e.tileKey);t&&this.featuresView.onTileData(t,e.data),this.layerView.view.labelManager.requestUpdate()}onTileError(e){const t=this.tiles.get(e.tileKey);Object(r.a)("esri-2d-debug")&&console.debug(e.tileKey,e.error),t&&this.featuresView.onTileError(t)}forceAttributeTextureUpload(){this.featuresView.attributeView.forceTextureUpload()}lockGPUUploads(){this.featuresView.attributeView.lockTextureUpload(),this.tiles.forEach(e=>e.lockUploads())}unlockGPUUploads(){this.featuresView.attributeView.unlockTextureUpload(),this.tiles.forEach(e=>e.unlockUploads())}async getMaterialItems(e){return this.featuresView.getMaterialItems(e)}invalidateLabels(){this.featuresView.hasLabels&&(this.tiles.forEach(e=>e.isDirty=!0),this.layerView.view.labelManager.requestUpdate())}createTile(e){const t=this.tileInfoView.getTileBounds(Object(n.d)(),e),s=new a.a(e,t);return this.featuresView.hasLabels&&this.layerView.view.labelManager.addTile(this.layerView,s),s}disposeTile(e){this.featuresView.removeChild(e),this.featuresView.hasLabels&&this.layerView.view.labelManager.removeTile(this.layerView,e.key.id),e.destroy(),this.layerView.view.labelManager.requestUpdate()}};b=Object(i.a)([Object(o.a)("esri.views.2d.layers.features.tileRenderers.SymbolTileRenderer")],b);var _=b;t.default=_},426:function(e,t,s){"use strict";function i(e,t){if(null!==t){e.push(t.length);for(const s of t)s.serialize(e);return e}e.push(0)}function r(e,t,s){const i=e.readInt32(),r=new Array(i);for(let i=0;i<r.length;i++)r[i]=t.deserialize(e,s);return r}s.d(t,"a",(function(){return r})),s.d(t,"b",(function(){return i}))},439:function(e,t,s){"use strict";var i=s(5),r=s(396),o=s(260),n=s(489),a=s(426);const l=i.a.getLogger("esri/views/2d/engine/webgl/collisions/Metric");class u{constructor(e,t,s,i,r){this.id=e,this.range=t,this.boxes=null,this.minZoom=-1,this.size=0,this.directionX=0,this.directionY=0,this.offsetX=0,this.offsetY=0,this.placementPadding=0,this.anchor=Object(o.b)(s,i),this.baseZoom=r}add(e,t,s){e.x=e.x+t,e.y=e.y+s,this.bounds?this.boxes?(this.boxes.push(e),this.bounds.extend(e)):(this.boxes=[this.bounds,e],this.bounds=this.bounds.clone(),this.bounds.extend(e)):this.bounds=e}computeIndex(){const e=this.anchor[0],t=this.anchor[1],s=Math.floor(e/r.d),i=Math.floor(t/r.d);this.xBucket=s,this.yBucket=i;const o=r.F/r.d;if(this.hasVV)return this.xOverflow=o,void(this.yOverflow=o);this.xOverflow=Math.min(o,Math.ceil(2*this.bounds.width/r.d)),this.yOverflow=Math.min(o,Math.ceil(2*this.bounds.height/r.d))}findCollisionDelta(e){const t=this.bounds.findCollisionDelta(e.bounds),s=this.boxes&&this.boxes.length,i=e.boxes&&e.boxes.length;return Math.abs(t)>r.f||!s&&!i?t:s&&i?this._boxesToBoxes(e):s?this._boxesToBox(e):this._boxToBoxes(e)}computeVVOffset(e,t){t||l.error("mapview-labeling","Unable to compute label offset. Expected an evaluator function but found "+t);let s=this.size;if(this.hasVV){const i=t(e);s=isNaN(i)||null==i||i===1/0?this.size:i}this._computeOffset(s)}setPlacementOffset(e,t,s,i,r){this.hasVV=e,this.size=t,this.placementPadding=Math.round(s),this.directionX=i,this.directionY=r}clone(){const e=new u(this.id,this.range,this.anchor[0],this.anchor[1],this.baseZoom);return e.minZoom=this.minZoom,this.bounds&&(e.bounds=this.bounds.clone()),this.boxes&&(e.boxes=this.boxes.map(e=>e.clone())),e.xBucket=this.xBucket,e.yBucket=this.yBucket,e.xOverflow=this.xOverflow,e.yOverflow=this.yOverflow,e.hasVV=this.hasVV,e.size=this.size,e.directionX=this.directionX,e.directionY=this.directionY,e.offsetX=this.offsetX,e.offsetY=this.offsetY,e}_boxToBoxes(e){let t=-1/0;for(const s of e.boxes){const e=this.bounds.findCollisionDelta(s);t=Math.max(e,t)}return t}_boxesToBox(e){let t=this.boxes[0].findCollisionDelta(e.bounds);for(let s=1;s<this.boxes.length;s++){const i=this.boxes[s].findCollisionDelta(e.bounds);t=Math.max(i,t)}return t}_boxesToBoxes(e){let t=-1/0;for(let s=0;s<this.boxes.length;s++){const i=this.boxes[s];for(const s of e.boxes){const e=i.findCollisionDelta(s);t=Math.max(e,t)}}return t}_computeOffset(e){this.offsetX=this.directionX*(e/2+this.placementPadding),this.offsetY=this.directionY*(e/2+this.placementPadding)}serialize(e){return e.push(this.id),this.bounds.serialize(e),e.push(this.range.from),e.push(this.range.count),e.push(this.anchor[0]),e.push(this.anchor[1]),e.push(this.baseZoom),e.push(this.hasVV?1:0),e.push(this.size),e.writeF32(this.directionX),e.writeF32(this.directionY),e.push(this.offsetX),e.push(this.offsetY),e.push(this.placementPadding),Object(a.b)(e,this.boxes),e}static deserialize(e){const t=e.readInt32(),s=n.a.deserialize(e),i={from:e.readInt32(),count:e.readInt32()},r=e.readInt32(),o=e.readInt32(),l=e.readInt32(),c=e.readInt32(),d=e.readInt32(),h=e.readF32(),f=e.readF32(),p=e.readInt32(),y=e.readInt32(),b=e.readInt32(),_=Object(a.a)(e,n.a),m=new u(t,i,r,o,l);return m.bounds=s,m.boxes=_,m.setPlacementOffset(!!c,d,b,h,f),m.offsetX=p,m.offsetY=y,m.computeIndex(),c||m._computeOffset(d),m}}t.a=u},440:function(e,t,s){"use strict";var i=s(398),r=class{constructor(){this.vertexData=new Map,this.vertexCount=0,this.indexData=[]}clear(){this.vertexData.clear(),this.vertexCount=0,this.indexData=[]}update(e,t,s){for(const t in e)this.vertexData.set(t,e[t]);for(const t in this.vertexData)null===e[t]&&this.vertexData.delete(t);this.vertexCount=t,this.indexData=s}};class o{constructor(e,t,s,i=0,r=0){this.id=e,this.geometryType=t,this.materialKey=s,this.minZoom=i,this.maxZoom=r,this.meshData=null,this.symbolLevel=0,this.zOrder=0,this.vertexFrom=0,this.vertexCount=0,this.indexFrom=0,this.indexCount=0}get sortKey(){return void 0===this._sortKey&&this._computeSortKey(),this._sortKey}clone(){return this.copy()}copy(){const e=new o(this.id,this.geometryType,this.materialKey);return e.vertexFrom=this.vertexFrom,e.vertexCount=this.vertexCount,e.indexFrom=this.indexFrom,e.indexCount=this.indexCount,e.zOrder=this.zOrder,e.symbolLevel=this.symbolLevel,e.meshData=this.meshData,e.minZoom=this.minZoom,e.maxZoom=this.maxZoom,e}setMeshDataFromBuffers(e,t,s){const o=new r;for(const s in t){const r=t[s].stride,n=t[s].data,a=[],l=Object(i.o)(r);for(let t=0;t<r*e.vertexCount/l;++t)a[t]=n[t+r*e.vertexFrom/l];o.vertexData.set(s,a)}o.indexData.length=0;for(let t=0;t<e.indexCount;++t)o.indexData[t]=s[t+e.indexFrom]-e.vertexFrom;o.vertexCount=e.vertexCount,this.meshData=o}readMeshDataFromBuffers(e,t){this.meshData?this.meshData.clear():this.meshData=new r;for(const t in e){const s=e[t].stride,r=e[t].data,o=[],n=Object(i.o)(s);for(let e=0;e<s*this.vertexCount/n;++e)o[e]=r[e+s*this.vertexFrom/n];this.meshData.vertexData.set(t,o)}this.meshData.indexData.length=0;for(let e=0;e<this.indexCount;++e)this.meshData.indexData[e]=t[e+this.indexFrom]-this.vertexFrom;this.meshData.vertexCount=this.vertexCount}writeMeshDataToBuffers(e,t,s,r){for(const s in t){const r=t[s].stride,o=this.meshData.vertexData.get(s),n=t[s].data,a=Object(i.o)(r);for(let t=0;t<r*this.meshData.vertexCount/a;++t)n[t+r*e/a]=o[t]}for(let t=0;t<this.meshData.indexData.length;++t)r[t+s]=this.meshData.indexData[t]+e;this.vertexFrom=e,this.vertexCount=this.meshData.vertexCount,this.indexFrom=s,this.indexCount=this.meshData.indexData.length}static writeAllMeshDataToBuffers(e,t,s){let i=0,r=0;for(const o of e)o.writeMeshDataToBuffers(i,t,r,s),i+=o.vertexCount,r+=o.indexCount}_computeSortKey(){this._sortKey=(31&this.symbolLevel)<<12|(127&this.zOrder)<<4|7&this.geometryType}serialize(e){return e.push(this.geometryType),e.push(this.materialKey),e.push(this.vertexFrom),e.push(this.vertexCount),e.push(this.indexFrom),e.push(this.indexCount),e.push(this.minZoom),e.push(this.maxZoom),e}static deserialize(e,t){const s=e.readInt32(),i=e.readInt32(),r=new o(t.id,s,i);return r.vertexFrom=e.readInt32(),r.vertexCount=e.readInt32(),r.indexFrom=e.readInt32(),r.indexCount=e.readInt32(),r.minZoom=e.readInt32(),r.maxZoom=e.readInt32(),r}}t.a=o},443:function(e,t,s){"use strict";t.a=class{constructor(e,t){this._pos=0;const s=t?this._roundToNearest(t,e.BYTES_PER_ELEMENT):40;this._array=new ArrayBuffer(s),this._buffer=new e(this._array),this._ctor=e}get length(){return this._pos}_roundToNearest(e,t){const s=Math.round(e);return s+(t-s%t)}_ensureSize(e){if(this._pos+e>=this._buffer.length){const t=this._roundToNearest(1.5*(this._array.byteLength+e*this._buffer.BYTES_PER_ELEMENT),this._buffer.BYTES_PER_ELEMENT),s=new ArrayBuffer(t),i=new this._ctor(s);i.set(this._buffer,0),this._array=s,this._buffer=i}}writeF32(e){this._ensureSize(1);const t=this._pos;return new Float32Array(this._array,4*this._pos,1)[0]=e,this._pos++,t}push(e){this._ensureSize(1);const t=this._pos;return this._buffer[this._pos++]=e,t}writeFixed(e){this._buffer[this._pos++]=e}setValue(e,t){this._buffer[e]=t}getValue(e){return this._buffer[e]}incr(e){this._buffer[e]++}decr(e){this._buffer[e]--}writeRegion(e){this._ensureSize(e.length);const t=this._pos;return this._buffer.set(e,this._pos),this._pos+=e.length,t}buffer(){const e=this._array.slice(0,4*this._pos);return this.destroy(),e}toArray(){const e=this._array,t=[];for(let s=0;s<e.byteLength/4;s++)t.push(e[s]);return t}seek(e){this._pos=e}destroy(){this._array=null,this._buffer=null}}},464:function(e,t,s){"use strict";function i(){return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}function r(e){return[e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15]]}function o(e,t){return new Float64Array(e,t,16)}s.d(t,"a",(function(){return n})),s.d(t,"b",(function(){return i})),s.d(t,"c",(function(){return r})),s.d(t,"d",(function(){return o}));const n=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];Object.freeze({__proto__:null,create:i,clone:r,fromValues:function(e,t,s,i,r,o,n,a,l,u,c,d,h,f,p,y){return[e,t,s,i,r,o,n,a,l,u,c,d,h,f,p,y]},createView:o,IDENTITY:n})},473:function(e,t,s){"use strict";s.d(t,"a",(function(){return l}));var i=s(4),r=s(148),o=s(147),n=s(216),a=s(451);class l extends a.a{constructor(e,t,s,i=s){super(),this.triangleCountReportedInDebug=0,this.transforms={dvs:Object(n.b)(),tileMat3:Object(n.b)()},this.triangleCount=0,this.key=new o.a(e),this.bounds=t,this.size=s,this.coordRange=i}destroy(){this.texture&&(this.texture.dispose(),this.texture=null)}get coords(){return this._coords}get bounds(){return this._bounds}set bounds(e){this._coords=[e[0],e[3]],this._bounds=e}setTransform(e,t){Object(i.a)("esri-2d-debug")&&null==t&&console.debug("Tried to set tile transform but lod resolution was null");const s=t/(e.resolution*e.pixelRatio),o=this.transforms.tileMat3,[n,a]=e.toScreenNoRotation([0,0],this.coords),l=this.size[0]/this.coordRange[0]*s,u=this.size[1]/this.coordRange[1]*s;Object(r.j)(o,l,0,0,0,u,0,n,a,1),Object(r.g)(this.transforms.dvs,e.displayViewMat3,o)}}},480:function(e,t,s){"use strict";var i=s(440),r=s(426),o=s(439);class n{constructor(e){this.insertAfter=null,this.id=e,this.displayRecords=[],this.metrics=[]}copy(){const e=new n(this.id);return e.set(this),e}clone(){const e=new n(this.id);return e.displayRecords=this.displayRecords.map(e=>e.clone()),e.metrics=this.metrics.map(e=>e.clone()),e.insertAfter=this.insertAfter,e}set(e){this.id=e.id,this.displayRecords=e.displayRecords,this.metrics=e.metrics,this.insertAfter=e.insertAfter}serialize(e){return e.push(this.id),Object(r.b)(e,this.metrics),Object(r.b)(e,this.displayRecords),e}static deserialize(e){const t=e.readInt32(),s=new n(t),a={id:t},l=Object(r.a)(e,o.a);return l.length&&(s.metrics=l),s.displayRecords=Object(r.a)(e,i.a,a),s}}t.a=n},483:function(e,t,s){"use strict";var i=s(397),r=s(538),o=s(534),n=s(524);const a=(e,t)=>e.key.level-t.key.level!=0?e.key.level-t.key.level:e.key.row-t.key.row!=0?e.key.row-t.key.row:e.key.col-t.key.col;t.a=class extends n.a{constructor(e){super(),this._tileInfoView=e}renderChildren(e){this.sortChildren(a),this.setStencilReference(),super.renderChildren(e)}createRenderParams(e){const{state:t}=e;return{...super.createRenderParams(e),requiredLevel:this._tileInfoView.getClosestInfoForScale(t.scale).level,displayLevel:this._tileInfoView.tileInfo.scaleToZoom(t.scale)}}prepareRenderPasses(e){const t=e.registerRenderPass({name:"stencil",brushes:[o.a],drawPhase:i.c.DEBUG|i.c.MAP,target:()=>this.getStencilTarget()}),s=e.registerRenderPass({name:"tileInfo",brushes:[r.a],drawPhase:i.c.DEBUG,target:()=>this.children,has:"esri-tiles-debug"});return[...super.prepareRenderPasses(e),t,s]}getStencilTarget(){return this.children}updateTransforms(e){for(const t of this.children){const s=this._tileInfoView.getTileResolution(t.key);t.setTransform(e,s)}}setStencilReference(){let e=1;for(const t of this.children)t.stencilRef=e++}}},490:function(e,t,s){"use strict";s.d(t,"a",(function(){return o}));var i=s(398);class r{constructor(e,t,s){this.data=e,this.stride=t,this.vertexCount=s}static decode(e){const t=Object(i.c)(e.data,e.stride),s=e.stride,o=e.vertexCount;return new r(t,s,o)}static fromVertexVector(e){const t=Object(i.c)(e.data.buffer(),e.stride),s=e.stride,o=e.vertexCount;return new r(t,s,o)}}class o{constructor(e,t,s){this.geometryType=e,this.indexBuffer=new Uint32Array(t),this.namedBuffers=s}static decode(e){const t=e.geometryType,s=e.indexBuffer,i={};for(const t in e.namedBuffers)i[t]=r.decode(e.namedBuffers[t]);return new o(t,s,i)}static fromVertexVectors(e){const t=e.geometryType,s=e.indexVector.buffer(),i={};for(const t in e.namedVectors)i[t]=r.fromVertexVector(e.namedVectors[t]);return new o(t,s,i)}}},494:function(e,t,s){"use strict";s.d(t,"a",(function(){return r})),s.d(t,"b",(function(){return i}));const i=(e,t)=>e&&((...e)=>t.warn("DEBUG:",...e))||(()=>null),r=!1},495:function(e,t,s){"use strict";function i(){return[1,0,0,0,1,0,0,0,1]}function r(e,t){return new Float64Array(e,t,9)}s.d(t,"a",(function(){return i})),s.d(t,"b",(function(){return r}));Object.freeze({__proto__:null,create:i,clone:function(e){return[e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8]]},fromValues:function(e,t,s,i,r,o,n,a,l){return[e,t,s,i,r,o,n,a,l]},createView:r})},497:function(e,t,s){"use strict";s.d(t,"a",(function(){return u}));var i=s(440),r=s(426),o=s(439),n=s(480),a=class{constructor(e){this._pos=0,this._buffer=e,this._i32View=new Int32Array(this._buffer),this._f32View=new Float32Array(this._buffer)}readInt32(){return this._i32View[this._pos++]}readF32(){return this._f32View[this._pos++]}},l=s(443);class u{constructor(e,t){this.vertexVectorsMap=e,this._currentIndex=-1,this._currentRecordOffset=0,this._currentMetricOffset=0;const s=4*(4*t.features+1),i=4*(8*t.records+1),r=4*(20*t.metrics+1);this._bufDisplayObjects=new l.a(Uint32Array,s+4),this._bufDisplayRecords=new l.a(Uint32Array,i+4),this._bufMetrics=new l.a(Uint32Array,r+4),this._bufDisplayObjects.push(0),this._bufDisplayRecords.push(0),this._bufMetrics.push(0)}get vertexBuffersMap(){if(!this._vertexBuffersMap){this._vertexBuffersMap={};for(let e=0;e<this.vertexVectorsMap.length;e++)this._vertexBuffersMap[e]=this.vertexVectorsMap[e].intoBuffers();this.vertexVectorsMap=null}return this._vertexBuffersMap}get(e){return this.vertexVectorsMap[e]}currentDisplayRecordCount(){return this._bufDisplayRecords[this._currentRecordOffset]}writeDisplayObject(e,t){this._bufDisplayObjects.incr(0),this._currentIndex=this._bufDisplayObjects.push(e),this._bufDisplayObjects.push(t),this._bufDisplayObjects.push(0),this._bufDisplayObjects.push(0),this._currentRecordOffset=0,this._currentMetricOffset=0}hasDisplayRecords(){return!(0===this._currentRecordOffset)}endDisplayObject(){this.hasDisplayRecords()||this._rollbackDisplayObject()}writeDisplayRecord(e,t,s,i,r,o,n=0,a=0){0===this._currentRecordOffset&&(this._currentRecordOffset=this._bufDisplayRecords.push(0),this._bufDisplayObjects.setValue(this._currentIndex+2,this._currentRecordOffset)),this._bufDisplayRecords.incr(this._currentRecordOffset),this._bufDisplayRecords.push(e),this._bufDisplayRecords.push(t),this._bufDisplayRecords.push(s),this._bufDisplayRecords.push(i),this._bufDisplayRecords.push(r),this._bufDisplayRecords.push(o),this._bufDisplayRecords.push(n),this._bufDisplayRecords.push(a)}writeMetrics(e){0===this._currentMetricOffset&&(this._bufDisplayObjects.setValue(this._currentIndex+3,this._bufMetrics.length),this._currentMetricOffset=this._bufMetrics.length),Object(r.b)(this._bufMetrics,e)}static deserializeDisplayObjects(e){const{bufDisplayObjects:t,bufMetrics:s,bufRecords:l}=e,u=new a(t),c=new a(l),d=new a(s),h=[];let f=u.readInt32();for(c.readInt32(),d.readInt32();f--;){const e=u.readInt32(),t=u.readInt32(),s=u.readInt32(),a=u.readInt32(),l=new n.a(e);0!==t&&(l.insertAfter=t),0!==s&&(l.displayRecords=Object(r.a)(c,i.a,{id:e})),0!==a&&(l.metrics=Object(r.a)(d,o.a)),h.push(l)}return h}encode(e,t){const s={};for(let e=0;e<this.vertexVectorsMap.length;e++){const i=this.vertexVectorsMap[e];s[e]={},i.transfer(s[e],t)}e.bufDisplayObjects=this._bufDisplayObjects.buffer(),e.bufRecords=this._bufDisplayRecords.buffer(),e.bufMetrics=this._bufMetrics.buffer(),t.push(e.bufDisplayObjects),t.push(e.bufMetrics),t.push(e.bufRecords),e.vertexBuffersMap=s,this.destroy()}destroy(){this.vertexVectorsMap=null,this._bufDisplayObjects=null,this._bufDisplayRecords=null,this._bufMetrics=null}_rollbackDisplayObject(){this._bufDisplayObjects.decr(0),this._bufDisplayObjects.seek(this._bufDisplayObjects.length-4),this._currentIndex=this._bufDisplayObjects.length}}},513:function(e,t,s){"use strict";s.d(t,"a",(function(){return D}));var i=s(4),r=s(8),o=s(527),n=s(26),a=s(396),l=s(72),u=s(298),c=s(260),d=s(473),h=s(397),f=s(398);function p(e,t,s){if(!e.allDirty)if(null!=e.from&&null!=e.count){const i=Math.min(e.from,t),r=Math.max(e.from+e.count,t+s)-i;e.from=i,e.count=r}else e.from=t,e.count=s}var y=class{constructor(){this._dirties=Object(f.e)(()=>({indices:{from:null,count:null,allDirty:!1}}),()=>({vertices:{from:null,count:null,allDirty:!1}}))}hasDirty(){for(const e of this._dirties)if(null!==e.data.indices.count||e.data.indices.allDirty)return!0;return!1}markAllClean(){for(const e of this._dirties){e.data.indices.from=null,e.data.indices.count=null,e.data.indices.allDirty=!1;for(const t in e.buffers)e.buffers[t].data.vertices.from=null,e.buffers[t].data.vertices.count=null,e.buffers[t].data.vertices.allDirty=!1}}markAllDirty(){for(const e of this._dirties){e.data.indices.allDirty=!0;for(const t in e.buffers)e.buffers[t].data.vertices.allDirty=!0}}forEach(e){for(let t=0;t<this._dirties.length;++t){const s=this._dirties[t],i={};for(const e in s.buffers){const t=s.buffers[e].data.vertices;(t.allDirty||null!=t.from&&null!=t.count&&t.count>0)&&(i[e]=t)}const r=s.data.indices;let o;o=r.allDirty||null!=r.from&&null!=r.count&&r.count>0?{indices:r,vertices:i}:{indices:null,vertices:i},(o.indices||Object.keys(o).length>0)&&e(o,t)}}markDirtyIndices(e,t,s){p(this._dirties[e].data.indices,t,s)}markDirtyVertices(e,t,s,i){p(this._dirties[e].buffers[t].data.vertices,s,i)}};class b{constructor(e){this._largestRange=null,this._parent=e,this._updateLargestRange()}get largestRange(){return this._largestRange}rangeCreated(e){(!this._largestRange||e.count>this._largestRange.count)&&(this._largestRange=e)}rangeResized(e,t){e===this._largestRange?e.count<t&&this._updateLargestRange():(!this._largestRange||e.count>this._largestRange.count)&&(this._largestRange=e)}findBestRange(e){let t=this._parent._freeHead,s=null;for(;null!==t;)t.count>=e&&(!s||t.count-e<s.count-e)&&(s=t),t=t.next;return s}findAdjacentRanges(e,t){let s=!0,i=!1,r=null,o=this._parent._freeHead;for(;s&&!i;){const n=null!==r?r.from+r.count:0,a=null!==o?o.from:this._parent._size;e>=n&&e+t<=a?(s=!1,i=!0):null!==o?(r=o,o=o.next):s=!1}return[r,o]}_updateLargestRange(){let e=null,t=this._parent._freeHead;for(;null!==t;)(!e||t.count>e.count)&&(e=t),t=t.next;this._largestRange=e}}class _{constructor(e,t){this._allocated=0,this._size=e,this._freeHead=e>0?{from:0,count:e,prev:null,next:null}:null,this._bookKeeper=t||new b(this),this._freeHead&&this._bookKeeper.rangeCreated(this._freeHead)}allocate(e){const t=this._bookKeeper.findBestRange(e);if(null===t)return-1;const s=t.from,i=t.count;if(t.from+=e,t.count-=e,this._bookKeeper.rangeResized(t,s,i),this._allocated+=e,0===t.count){const e=null!==t.prev?this._freeHead:t.next;_._removeRange(t),this._freeHead=e}return s}free(e,t){const[s,i]=this._bookKeeper.findAdjacentRanges(e,t),r={from:e,count:t,prev:s,next:i};if(null!==s&&(s.next=r),null!==i&&(i.prev=r),this._bookKeeper.rangeCreated(r),this._allocated-=t,null!==i&&r.from+r.count===i.from){const e=r.from,t=r.count;_._fuse(r,i),_._removeRange(i),this._bookKeeper.rangeResized(r,e,t),this._bookKeeper.rangeResized(i,void 0,0)}if(null!==s&&s.from+s.count===r.from){const e=s.from,t=s.count;_._fuse(s,r),_._removeRange(r),this._bookKeeper.rangeResized(s,e,t),this._bookKeeper.rangeResized(r,void 0,0)}this._freeHead=null!==r.prev?this._freeHead:r}get fragmentation(){const e=this._size-this._allocated;return 0===e?0:1-this._bookKeeper.largestRange.count/e}static _removeRange(e){null!==e.prev?null!==e.next?(e.prev.next=e.next,e.next.prev=e.prev):e.prev.next=null:null!==e.next&&(e.next.prev=null)}static _fuse(e,t){e.count+=t.count,e.next=t.next,t.from+=t.count,t.count=0,null!==t.next&&(t.next.prev=e)}}const m=["FILL","LINE","MARKER","TEXT","LABEL"];class x{constructor(e,t,s,i){this._strides=e,this._displayList=t,this._freeListsAndStorage={},this._dirtyMap=null,this._dirtyMap=s;for(const t in e){this._freeListsAndStorage[t]={vtxFreeList:i?new _(i):null,idxFreeList:i?new _(i):null,vertexBuffers:{},indexBuffer:i?new Uint32Array(i):null};for(const s in e[t])this._freeListsAndStorage[t].vertexBuffers[s]={data:i?Object(f.b)(i,e[t][s]):null,stride:e[t][s]}}}static fromTileData(e,t){const s=function(e){const t=e.getStrides(),s={};for(let e=0;e<t.length;e++)s[m[e]]=t[e];return s}(e),i=[0,0,0,0,0],r=[0,0,0,0,0],o=e.tileDisplayData.displayObjects;for(const e of o)for(const t of e.displayRecords)i[t.geometryType]=Math.max(i[t.geometryType],t.vertexFrom+t.vertexCount),r[t.geometryType]=Math.max(r[t.geometryType],t.indexFrom+t.indexCount);const n=new x(s,e.tileDisplayData.displayList,t,null);for(let t=0;t<e.tileBufferData.geometries.length;++t){const s=i[t],o=r[t],a=e.tileBufferData.geometries[t],l=m[t],u=n._storageFor(l),c=e.tileBufferData.geometries[t].indexBuffer;let d;u.indexBuffer=c,u.idxFreeList=new _(c.length),u.idxFreeList.allocate(o);for(const s in a.vertexBuffer){const i=e.tileBufferData.geometries[t].vertexBuffer[s];u.vertexBuffers[s].data=i.data,u.vertexBuffers[s].stride=i.stride;const r=Object(f.o)(i.stride),o=i.data.length*r/i.stride;d||(d=o)}u.vtxFreeList=new _(d),u.vtxFreeList.allocate(s)}return n}delete(e){const t=m[e.geometryType];this._freeVertices(t,e.vertexFrom,e.vertexCount),this._freeIndices(t,e.indexFrom,e.indexCount),this._displayList.removeFromList(e),e.vertexFrom=void 0,e.indexFrom=void 0}setMeshData(e,t,s,i,r){const o=m[e.geometryType];e.meshData=null;let n=void 0,a=void 0;void 0===e.vertexFrom?(a=t.vertexCount,n=this._allocateVertices(o,a)):t.vertexCount>e.vertexCount?(this._freeVertices(o,e.vertexFrom,e.vertexCount),a=t.vertexCount,n=this._allocateVertices(o,a)):t.vertexCount===e.vertexCount?(n=e.vertexFrom,a=e.vertexCount):(this._freeVertices(o,e.vertexFrom+t.vertexCount,e.vertexCount-t.vertexCount),n=e.vertexFrom,a=t.vertexCount);let l=!0,u=void 0,c=void 0,d=void 0;if(void 0===e.indexFrom?(u=r,d=t.indexCount,c=this._allocateIndices(o,d)):t.indexCount>e.indexCount?(u=this._displayList.removeFromList(e),this._freeIndices(o,e.indexFrom,e.indexCount),d=t.indexCount,c=this._allocateIndices(o,d)):t.indexCount===e.indexCount?(l=!1,c=e.indexFrom,d=e.indexCount):(u=this._displayList.removeFromList(e),this._freeIndices(o,e.indexFrom+t.indexCount,e.indexCount-t.indexCount),c=e.indexFrom,d=t.indexCount),-1!==n&&-1!==c){const r=this._storageFor(o);if(Object(f.d)(n,c,r.vertexBuffers,r.indexBuffer,t,s,i),e.vertexFrom=n,e.indexFrom=c,e.vertexCount=t.vertexCount,e.indexCount=t.indexCount,this._dirtyMap){this._dirtyMap.markDirtyIndices(e.geometryType,e.indexFrom,e.indexCount);for(const t in s)this._dirtyMap.markDirtyVertices(e.geometryType,t,e.vertexFrom,e.vertexCount)}return l&&this._displayList.addToList(e,u),!0}return-1!==n&&this._freeVertices(o,n,a),-1!==c&&this._freeIndices(o,c,d),e.setMeshDataFromBuffers(t,s,i),e.vertexFrom=void 0,e.vertexCount=0,e.indexFrom=void 0,e.indexCount=0,!1}tryAddMeshData(e,t){const s=t.vertexBuffer,i=t.indexBuffer,r=m[e.geometryType],o=this._allocateVertices(r,e.vertexCount);if(-1===o)return this._freeVertices(r,o,e.vertexCount),!1;const n=this._allocateIndices(r,e.indexCount);if(-1===n)return this._freeVertices(r,o,e.vertexCount),this._freeIndices(r,n,e.indexCount),!1;const a=this._storageFor(r);if(Object(f.d)(o,n,a.vertexBuffers,a.indexBuffer,e,s,i),e.vertexFrom=o,e.indexFrom=n,this._dirtyMap){this._dirtyMap.markDirtyIndices(e.geometryType,e.indexFrom,e.indexCount);for(const t in s)this._dirtyMap.markDirtyVertices(e.geometryType,t,o,e.vertexCount)}return this._displayList.addToList(e),!0}_allocateVertices(e,t){const s=this._storageFor(e),i=s.vtxFreeList.allocate(t);return-1===i||s.vtxFreeList.fragmentation>.5?-1:i}_freeVertices(e,t,s){const r=this._storageFor(e);if(r.vtxFreeList.free(t,s),Object(i.a)("esri-feature-tiles-debug"))for(const i in r.vertexBuffers){const o=r.vertexBuffers[i].data,n=this._stridesFor(e,i),a=Object(f.o)(n),l=t*n/a,u=s*n/a;for(let e=l;e<l+u;++e)o[e]=0}}_freeIndices(e,t,s){const r=this._storageFor(e);if(r.idxFreeList.free(t,s),Object(i.a)("esri-feature-tiles-debug")){const e=r.indexBuffer;for(let i=t;i<t+s;++i)e[i]=0}}_allocateIndices(e,t){const s=this._storageFor(e),i=s.idxFreeList.allocate(t);return-1===i||s.idxFreeList.fragmentation>.5?-1:i}_storageFor(e){return this._freeListsAndStorage[e]}_stridesFor(e,t){return this._strides[e][t]}}var v=x,g=(s(404),s(405));s(406),s(407),s(408),s(409),s(411);const O=new Set;class D extends d.a{constructor(e,t,s=!1){super(e,t,[a.F,a.F]),this._data=null,this._displayList=null,this._wglBuffers=null,this._deferPatches=!1,this._dirtyMap=new y,this._labelIndex=null,this._lastCommitTime=0,this._patchQueue=new o.a(100),this.fader=new class{constructor(e=400){this.duration=e,this._lastTime=0,this._elapsed=0,this._value=0,this._finished=!1}get value(){return this._value}reset(){this._lastTime=0,this._elapsed=0,this._value=0}step(){const e=performance.now();if(0===this._lastTime)return this._lastTime=e,this._value=0,!0;if(this._elapsed>=this.duration)return!0;const t=e-this._lastTime;return this._elapsed+=t,this._lastTime=e,this._value=Math.min(this._elapsed/this.duration,1),!1}},this._patchCount=0,this._dirty=!0,this._replaceBuffers=!1,this._uploadsLocked=!1,this._hasData=!1,this._invalidated=!1,this.transforms.labelMat2d=Object(u.a)(),this._ensureCorrectZOrder=s,this._deferPatches=!s}destroy(){super.destroy(),this.clear()}get displayObjects(){var e;return null!=(e=this._displayObjects)?e:[]}get isDirty(){return this._dirty}get hasData(){return!!this._hasData}get labelIndex(){return this._labelIndex}set isDirty(e){this._dirty=e,this.requestRender()}get patchCount(){return this._patchCount}getGeometry(e){return this._wglBuffers&&this._wglBuffers.has(e)?this._wglBuffers.get(e):null}getDisplayList(){return this._displayList}setTransform(e,t){super.setTransform(e,t);const s=this.transforms.labelMat2d,i=e.getScreenTransform(s,t),r=Object(c.a)();Object(n.n)(r,this.coords,i),Object(l.d)(s),Object(l.h)(s,s,r),Object(l.e)(s,e.viewMat2d,s)}setData(e){const t=e.addOrUpdate,s=e.remove;e.clear&&(this.clear(),this._patchQueue.clear(),this._hasData=!1),"replace"===e.type&&(this._replaceBuffers=!0,this._patchQueue.clear(),this._data=null),!this._data&&t&&t.tileDisplayData.displayObjects.length?(t.tileDisplayData.computeDisplayList(this._ensureCorrectZOrder),this._dirtyMap=new y,this._dispRecStore=v.fromTileData(t,this._dirtyMap),this._data=t,this._dirtyMap.markAllDirty(),this._patchCount++,this._hasData=!0,e.end&&this.ready()):this._data&&(t&&t.tileDisplayData.displayObjects.length||s.length)?this._deferPatches?this._patchQueue.enqueue(e):this._doPatchData(e):e.end&&this.ready(),e.end&&!this._data&&this.clear(),this.requestRender(),this.emit("change")}lockUploads(){this._uploadsLocked=!0}unlockUploads(){this._uploadsLocked=!1,this.requestRender()}commitChanges(e){if(!e.time||e.time!==this._lastCommitTime){if(this._lastCommitTime=e.time,this.fader.step()||this.requestRender(),this._patchQueue.size){const e=this._patchQueue.dequeue();Object(r.h)(e)&&(e.end&&this.ready(),this._patchCount++,this._doPatchData(e),this.requestRender(),this._hasData=!0)}this._uploadsLocked?this.requestRender():this.visible&&this._data&&(this._replaceBuffers&&(this._wglBuffers&&this._wglBuffers.dispose(),this._wglBuffers=null,this._replaceBuffers=!1),this._wglBuffers||(this._wglBuffers=new class{constructor(e){this.geometryMap=Object(f.e)(()=>({indexBuffer:g.a.createIndex(e,35044),vao:null}),(t,s)=>({vertexBuffer:g.a.createVertex(e,f.a[s])}))}dispose(){for(let e=0;e<5;e++){const t=this.geometryMap[e];if(t){t.data.vao&&t.data.vao.dispose(!1),t.data.indexBuffer&&t.data.indexBuffer.dispose();for(const e in t.buffers)t.buffers[e]&&t.buffers[e].data.vertexBuffer.dispose()}}}get(e){const t=this.geometryMap[e],s={};for(const e in t.buffers)s[e]=t.buffers[e].data.vertexBuffer;return{indexBuffer:t.data.indexBuffer,get vao(){return t.data.vao},set vao(e){t.data.vao=e},vertexBufferMap:s}}has(e){return null!=this.geometryMap[e]}upload(e,t){t.forEach((t,s)=>{this._upload(t,s,e)})}_upload(e,t,s){if(e.indices&&(e.indices.allDirty?this._uploadIndices(s,t):null!=e.indices.from&&null!=e.indices.count&&this._uploadIndices(s,t,e.indices.from,e.indices.count)),e.vertices){const i=e.vertices;for(const e in i){const r=i[e];r.allDirty?this._uploadVertices(s,t,e):null!=r.from&&null!=r.count&&this._uploadVertices(s,t,e,r.from,r.count)}}}_uploadVertices(e,t,s,i,r){const o=this.geometryMap[t];if(!o)return;const n=e.geometries[t].vertexBuffer[s];if(!n)return;const a=n.stride,l=n.data.buffer;o.buffers[s]&&l.byteLength>0&&(null!=i&&null!=r?o.buffers[s].data.vertexBuffer.setSubData(l,i*a,i*a,(i+r)*a):o.buffers[s].data.vertexBuffer.setData(l))}_uploadIndices(e,t,s,i){const r=this.geometryMap[t];if(!r)return;const o=e.geometries[t].indexBuffer.buffer;r.data.indexBuffer&&o.byteLength>0&&(null!=s&&null!=i?r.data.indexBuffer.setSubData(o,4*s,4*s,4*(s+i)):r.data.indexBuffer.setData(o))}}(e.context)),(this._dirtyMap.hasDirty()||this._invalidated)&&(this._invalidated=!1,this._wglBuffers.upload(this._data.tileBufferData,this._dirtyMap),this._displayList=this._data.tileDisplayData.displayList.clone(),this._displayObjects=this._data.tileDisplayData.displayObjects.slice(),this._rebuildLabelIndex(),this._dirtyMap.markAllClean()))}}clear(){this._data=null,this._displayList=null,this._dispRecStore=null,this._wglBuffers&&(this._wglBuffers.dispose(),this._wglBuffers=null)}_doPatchData(e){try{if("new"===e.type){if(!e.addOrUpdate)return;this._invalidated=!0;const t=this._bulkAddFeatures(e);t&&(this._dirtyMap.markAllDirty(),this._data.reshuffleV2(e,t.objectIndex,t.recordIndex),this._dispRecStore=v.fromTileData(this._data,this._dirtyMap))}else this._invalidated=!0,this._patchData(e)||(this._dirtyMap.markAllDirty(),this._data.reshuffle(),this._dispRecStore=v.fromTileData(this._data,this._dirtyMap))}catch(e){Object(i.a)("esri-2d-debug")&&console.debug("Encountered an error while patching:",e)}this.requestRender()}_rebuildLabelIndex(){var e,t;if(null==(e=this._data)||null==(t=e.tileBufferData.geometries[h.d.LABEL])?void 0:t.indexBuffer.length){this.isDirty=!0,this._labelIndex=this._initLabelIndex();for(const e of this.displayObjects)for(const t of e.metrics)this._insertIntoLabelIndex(t)}}_insertIntoLabelIndex(e){e.xBucket<0||e.yBucket<0||e.yBucket>3||e.xBucket>3||this.labelIndex[e.yBucket][e.xBucket].push(e)}_initLabelIndex(){const e=[];for(let t=0;t<a.F/a.d;t++){e.push([]);for(let s=0;s<a.F/a.d;s++)e[t].push([])}return e}_bulkAddFeatures(e){const t=e.addOrUpdate.tileDisplayData.displayObjects,s=this._data.tileDisplayData.displayObjects;for(let i=0;i<t.length;i++){const r=t[i];for(let t=0;t<r.displayRecords.length;++t){const s=r.displayRecords[t],o=e.addOrUpdate.tileBufferData.geometries[s.geometryType];if(!this._dispRecStore.tryAddMeshData(s,o))return{objectIndex:i,recordIndex:t}}this._data.tileDisplayData.hasRegistry&&this._data.tileDisplayData.displayObjectRegistry.set(r.id,r),s.push(r)}return null}_patchData(e){let t=!0;const s=e.addOrUpdate&&e.addOrUpdate.tileDisplayData&&e.addOrUpdate.tileDisplayData.displayObjects||[],i=(e.remove||[]).slice();for(const e of s)null!=e.insertAfter&&i.push(e.id);for(const e of i){const t=this._data.tileDisplayData.displayObjectRegistry.get(e);if(t){this._data.tileDisplayData.displayList.removeFromList(t.displayRecords);for(const e of t.displayRecords)this._dispRecStore.delete(e);this._data.tileDisplayData.displayObjectRegistry.delete(e);const s=this._data.tileDisplayData.displayObjects.indexOf(t);this._data.tileDisplayData.displayObjects.splice(s,1)}}for(const i of s){let s,r=this._data.tileDisplayData.displayObjectRegistry.get(i.id);if(r){const e=r.displayRecords;r.set(i),r.displayRecords=e;const t=r.displayRecords.length;for(let e=0;e<t;++e){const t=r.displayRecords[e],s=i.displayRecords[e];(e>=i.displayRecords.length||t.geometryType!==s.geometryType||t.symbolLevel!==s.symbolLevel||t.zOrder!==s.zOrder||t.materialKey!==s.materialKey)&&(this._dispRecStore.delete(r.displayRecords[e]),e<i.displayRecords.length&&(r.displayRecords[e]=void 0))}r.displayRecords.length=i.displayRecords.length,r.metrics=i.metrics}else{let e;r=i.copy(),r.displayRecords=[],this._data.tileDisplayData.displayObjectRegistry.set(i.id,r);const t=this._data.tileDisplayData.displayObjects;if(null!=r.insertAfter)if(s={},r.insertAfter>=0){const s=this._data.tileDisplayData.displayObjectRegistry.get(r.insertAfter);s?(e=t.indexOf(s)+1,e<t.length?t.splice(e,0,r):(t.push(r),e=t.length)):(t.push(r),e=t.length)}else t.unshift(r),e=0;else t.push(r),e=t.length;if(s){let r;if(this._data.tileDisplayData.displayList.unified)r=i.displayRecords.length>0?1:0;else{O.clear();for(const e of i.displayRecords){const t=this._data.tileDisplayData.displayList.getDPInfoType(e.geometryType);O.add(t)}r=O.size}let o=0;for(let i=e-1;i>=0&&o<r;--i)for(let e=t[i].displayRecords.length-1;e>=0&&o<r;--e){const r=t[i].displayRecords[e],n=this._data.tileDisplayData.displayList.getDPInfoType(r.geometryType);s[n]||(s[n]=r,++o)}}}const o=i.displayRecords.length;for(let n=0;n<o;++n){const o=i.displayRecords[n];let a=r.displayRecords[n];a?(a.meshData=o.meshData,a.materialKey=o.materialKey):(a=o.copy(),a.vertexFrom=void 0,a.indexFrom=void 0,r.displayRecords[n]=a);const l=o.geometryType,u=this._data.tileDisplayData.displayList.getDPInfoType(l),c=e.addOrUpdate.tileBufferData.geometries[l],d=c.vertexBuffer,h=c.indexBuffer;let f=void 0;s&&(f=s[u]?this._data.tileDisplayData.displayList.splitAfter(s[u]):-1),t=this._dispRecStore.setMeshData(a,o,d,h,f)&&t,s&&null!=a.indexFrom&&null!=a.indexFrom&&(s[u]=a)}}return t}}},517:function(e,t,s){"use strict";s.d(t,"a",(function(){return B}));var i=s(398),r=class{constructor(){this._byGeometryType=null}get satisfied(){return!this._byGeometryType}reset(){this._byGeometryType=null}verticesFor(e){return this._byGeometryType?this._byGeometryType[e].vertices:0}indicesFor(e){return this._byGeometryType?this._byGeometryType[e].indices:0}needMore(e,t,s){if(!t&&!s)return;this._byGeometryType||(this._byGeometryType=[{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0}]);const i=this._byGeometryType[e];i.vertices+=t,i.indices+=s}};class o{constructor(){this.geometries=[{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}}]}clone(){const e=new o;for(let t=0;t<this.geometries.length;t++){const s=this.geometries[t],i=e.geometries[t];i.indexBuffer=s.indexBuffer.slice(),i.vertexBuffer={};for(const e in s.vertexBuffer){const{data:t,stride:r}=s.vertexBuffer[e];i.vertexBuffer[e]={data:t.slice(),stride:r}}}return e}static deserialize(e){const t=new o;for(let s=0;s<5;++s){t.geometries[s].indexBuffer=new Uint32Array(e.geometries[s].indexBuffer),t.geometries[s].vertexBuffer={};for(const r in e.geometries[s].vertexBuffer)t.geometries[s].vertexBuffer[r]={data:Object(i.c)(e.geometries[s].vertexBuffer[r].data,e.geometries[s].vertexBuffer[r].stride),stride:e.geometries[s].vertexBuffer[r].stride}}return t}serialize(){const e={geometries:[{indexBuffer:this.geometries[0].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[1].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[2].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[3].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[4].indexBuffer.buffer,vertexBuffer:{}}]};for(let t=0;t<5;++t)for(const s in this.geometries[t].vertexBuffer)e.geometries[t].vertexBuffer[s]={data:this.geometries[t].vertexBuffer[s].data.buffer,stride:this.geometries[t].vertexBuffer[s].stride};return e}getBuffers(){const e=[];for(let t=0;t<5;++t){e.push(this.geometries[t].indexBuffer.buffer);for(const s in this.geometries[t].vertexBuffer)e.push(this.geometries[t].vertexBuffer[s].data.buffer)}return e}}var n=o,a=s(440),l=s(5),u=s(397);const c=l.a.getLogger("esri.views.2d.engine.webgl.WGLDisplayList");function d(e,t,s,...i){t<e.length?e.splice(t,s,...i):e.push(...i)}const h=new Map;h.set(u.c.MAP,[u.d.FILL,u.d.LINE,u.d.MARKER,u.d.TEXT]),h.set(u.c.LABEL,[u.d.LABEL]),h.set(u.c.LABEL_ALPHA,[u.d.LABEL]);class f{constructor(e=!1){this.symbolLevels=[],this.unified=e}replay(e,t,s){if(this.unified)for(const i of this.symbolLevels)for(const r of i.zLevels){const i=r.geometryDPInfo;for(const r in i)if(i[r])for(const o of i[r]){const i=e.painter.getGeometryBrush(o.geometryType),r=t.getGeometry(o.geometryType);i.prepareState(e,t),i.drawGeometry(e,t,o,r,s)}}}get empty(){return!this.symbolLevels||0===this.symbolLevels.length}clear(){this.symbolLevels.length=0}addToList(e,t){if(Array.isArray(e))for(const s of e)this._addToList(s,t);else this._addToList(e,t)}removeFromList(e){Array.isArray(e)||(e=[e]);let t=null;for(const s of e)t=this._removeFromList(s);return t}byType(e,t){for(const s of this.symbolLevels)for(const i of s.zLevels){const s=i.geometryDPInfo,r=this.getDPInfoType(e);if(s[r])for(const e of s[r])t(e)}}clone(){const e=new f(this.unified);for(const t of this.symbolLevels)e.symbolLevels.push(t.clone());return e}splitAfter(e){const t=this._getDisplayList(e.symbolLevel,e.zOrder,e.geometryType),s=t.length,i=e.indexFrom+e.indexCount;for(let r=0;r<s;++r){const s=t[r];if(s.geometryType===e.geometryType&&i>s.indexFrom&&i<=s.indexFrom+s.indexCount){if(i<s.indexFrom+s.indexCount){const e=new p;e.geometryType=s.geometryType,e.materialKey=s.materialKey,e.indexFrom=i,e.indexCount=s.indexFrom+s.indexCount-i,t.splice(r+1,0,e),s.indexCount=i-s.indexFrom}return r}}}_addToList(e,t){const s=e.symbolLevel,i=e.zOrder,r=this._getDisplayList(s,i,e.geometryType),o=null!=t?t:r.length-1,n=o>=0&&o<r.length?r[o]:null;if(null===n||n.materialKey!==e.materialKey||n.indexFrom+n.indexCount!==e.indexFrom||this.unified&&n.geometryType!==e.geometryType){const t=new p;t.indexFrom=e.indexFrom,t.indexCount=e.indexCount,t.materialKey=e.materialKey,t.geometryType=e.geometryType,d(r,o+1,0,t)}else n.indexCount+=e.indexCount}_removeFromList(e){const t=e.symbolLevel,s=e.zOrder,i=this._getDisplayList(t,s,e.geometryType),r=i.length;let o=void 0;for(let t=0;t<r;++t){const s=i[t];if(e.indexFrom+e.indexCount>s.indexFrom&&e.indexFrom<s.indexFrom+s.indexCount&&(!this.unified||s.geometryType===e.geometryType)){o=t;break}}if(void 0!==o){const t=i[o];if(e.indexFrom===t.indexFrom)return t.indexCount-=e.indexCount,t.indexFrom+=e.indexCount,0===t.indexCount&&d(i,o,1),o-1;if(e.indexFrom+e.indexCount===t.indexFrom+t.indexCount)return t.indexCount-=e.indexCount,0===t.indexCount?(d(i,o,1),o-1):o;{const s=t.indexFrom,r=e.indexFrom-t.indexFrom,n=e.indexCount,a=t.indexFrom+t.indexCount-(e.indexFrom+e.indexCount);t.indexCount=r;const l=new p;return l.geometryType=t.geometryType,l.materialKey=t.materialKey,l.indexFrom=s+r+n,l.indexCount=a,d(i,o+1,0,l),o}}return null}_getDisplayList(e,t,s){let i;const r=this.symbolLevels.length;for(let t=0;t<r;t++)if(this.symbolLevels[t].symbolLevel===e){i=this.symbolLevels[t];break}let o;i||(i=new _,i.symbolLevel=e,this.symbolLevels.push(i));const n=i.zLevels.length;for(let e=0;e<n;e++)if(i.zLevels[e].zLevel===t){o=i.zLevels[e];break}let a;if(o||(o=new b,o.geometryDPInfo=new y,o.zLevel=t,i.zLevels.push(o)),this.unified)o.geometryDPInfo.unified||(o.geometryDPInfo.unified=[]),a=o.geometryDPInfo.unified;else switch(s){case u.d.FILL:o.geometryDPInfo.fill||(o.geometryDPInfo.fill=[]),a=o.geometryDPInfo.fill;break;case u.d.LINE:o.geometryDPInfo.line||(o.geometryDPInfo.line=[]),a=o.geometryDPInfo.line;break;case u.d.MARKER:o.geometryDPInfo.marker||(o.geometryDPInfo.marker=[]),a=o.geometryDPInfo.marker;break;case u.d.TEXT:o.geometryDPInfo.text||(o.geometryDPInfo.text=[]),a=o.geometryDPInfo.text;break;case u.d.LABEL:o.geometryDPInfo.label||(o.geometryDPInfo.label=[]),a=o.geometryDPInfo.label;break;default:console.error("Trying to add a record with geometry type '"+s+"'.")}return a}getDPInfoType(e){if(this.unified)return"unified";switch(e){case u.d.FILL:return"fill";case u.d.LINE:return"line";case u.d.MARKER:return"marker";case u.d.TEXT:return"text";case u.d.LABEL:return"label";default:return void c.error("DisplayList: Tried to convert unknown geometryType: "+e)}}}class p{constructor(){this.materialKey=null,this.indexFrom=0,this.indexCount=0}clone(){const e=new p;return e.geometryType=this.geometryType,e.materialKey=this.materialKey,e.indexFrom=this.indexFrom,e.indexCount=this.indexCount,e}}class y{constructor(){this.fill=null,this.line=null,this.marker=null,this.text=null,this.label=null,this.unified=null}clone(){const e=new y;return e.fill=this.fill&&this.fill.map(e=>e.clone()),e.line=this.line&&this.line.map(e=>e.clone()),e.marker=this.marker&&this.marker.map(e=>e.clone()),e.text=this.text&&this.text.map(e=>e.clone()),e.label=this.label&&this.label.map(e=>e.clone()),e.unified=this.unified&&this.unified.map(e=>e.clone()),e}}class b{constructor(){this.geometryDPInfo=new y}clone(){const e=new b;return e.zLevel=this.zLevel,e.geometryDPInfo=this.geometryDPInfo.clone(),e}}class _{constructor(){this.zLevels=[]}clone(){const e=new _;e.symbolLevel=this.symbolLevel;for(const t of this.zLevels)e.zLevels.push(t.clone());return e}}var m=f,x=s(426),v=s(480);function g(e){const t=[[],[],[],[],[]],s=e;for(const e of s)for(const s of e.displayRecords)t[s.geometryType].push(s);return t}class O{constructor(){}get hasRegistry(){return!!this._displayObjectRegistry}get displayObjectRegistry(){if(!this._displayObjectRegistry){this._displayObjectRegistry=new Map;for(const e of this.displayObjects)this._displayObjectRegistry.set(e.id,e)}return this._displayObjectRegistry}get displayList(){return this._displayList}computeDisplayList(e){if(this._displayList=new m(e),e)for(const e of this.displayObjects)for(const t of e.displayRecords)this._displayList.addToList(t);else{const e=g(this.displayObjects),t=e.length;for(let s=0;s<t;++s){const t=e[s];this._displayList.addToList(t)}}}clone(){const e=new O;return this.displayObjects&&(e.displayObjects=this.displayObjects.map(e=>e.clone())),e}serialize(e){return Object(x.b)(e,this.displayObjects),e}_deserializeObjects(e){const t=e.readInt32(),s=new Array(t),i=new Map;for(let t=0;t<s.length;++t){const r=v.a.deserialize(e);s[t]=r,i.set(r.id,r)}this.displayObjects=s,this._displayList=null,this._displayObjectRegistry=i}static deserialize(e){const t=new O;return t._deserializeObjects(e),t}}var D=O,T=s(443),R=s(497),w=s(490);const j=new r,I=new r;function E(e,t){const s={};for(const r in e){const o={data:Object(i.b)(t,e[r]),stride:e[r]};s[r]=o}return s}class B{constructor(){this.tileDisplayData=null,this.tileBufferData=null}reshuffle(){j.reset();const e=g(this.tileDisplayData.displayObjects);for(const t of e)for(const e of t)e&&j.needMore(e.geometryType,e.meshData?e.meshData.vertexCount:e.vertexCount,e.meshData?e.meshData.indexData.length:e.indexCount);const t=e.length,s=new n;for(let e=0;e<t;++e){s.geometries[e].indexBuffer=new Uint32Array(Math.round(1.5*j.indicesFor(e)));const t=[];for(const s in this.tileBufferData.geometries[e].vertexBuffer)t.push(this.tileBufferData.geometries[e].vertexBuffer[s].stride);const r=B._computeVertexAlignment(t),o=Math.round(1.5*j.verticesFor(e)),n=B._align(o,r);for(const t in this.tileBufferData.geometries[e].vertexBuffer){const r=this.tileBufferData.geometries[e].vertexBuffer[t].stride;s.geometries[e].vertexBuffer[t]={stride:r,data:Object(i.b)(n,r)}}}I.reset(),this.tileDisplayData.displayList.clear();for(let r=0;r<t;++r){const t=e[r];for(const e of t){if(e.meshData)e.writeMeshDataToBuffers(I.verticesFor(r),s.geometries[r].vertexBuffer,I.indicesFor(r),s.geometries[r].indexBuffer),e.meshData=null;else{const t=this.tileBufferData.geometries[r].vertexBuffer,o=this.tileBufferData.geometries[r].indexBuffer,n=s.geometries[r].vertexBuffer,a=s.geometries[r].indexBuffer,l=I.verticesFor(r),u=I.indicesFor(r);Object(i.d)(l,u,n,a,e,t,o),e.vertexFrom=l,e.indexFrom=u}I.needMore(r,e.vertexCount,e.indexCount)}this.tileDisplayData.displayList.unified||this.tileDisplayData.displayList.addToList(t)}if(this.tileDisplayData.displayList.unified)for(const e of this.tileDisplayData.displayObjects)this.tileDisplayData.displayList.addToList(e.displayRecords);this.tileBufferData=s}reshuffleV2(e,t,s){const r=e.addOrUpdate.tileDisplayData.displayObjects,o=this.tileDisplayData.displayObjects;j.reset();for(let e=0;e<o.length;e++){const t=o[e];for(let e=0;e<t.displayRecords.length;e++){const s=t.displayRecords[e];j.needMore(s.geometryType,s.vertexCount,s.indexCount)}}for(let e=t;e<r.length;e++){const i=r[e];for(let r=e===t?s:0;r<i.displayRecords.length;r++){const e=i.displayRecords[r];j.needMore(e.geometryType,e.vertexCount,e.indexCount)}}const a=new n;for(let e=0;e<5;e++){a.geometries[e].indexBuffer=new Uint32Array(Math.round(1.5*j.indicesFor(e)));const t=[],s=this.tileBufferData.geometries[e].vertexBuffer;for(const e in s)t.push(s[e].stride);const r=B._computeVertexAlignment(t),o=Math.round(1.5*j.verticesFor(e)),n=B._align(o,r);for(const t in s){const r=s[t].stride,o=Object(i.b)(n,r);a.geometries[e].vertexBuffer[t]={stride:r,data:o}}}I.reset(),this.tileDisplayData.displayList.clear();for(let e=0;e<o.length;e++){const t=o[e];for(let e=0;e<t.displayRecords.length;e++){const s=t.displayRecords[e],r=s.geometryType,o=this.tileBufferData.geometries[r].vertexBuffer,n=this.tileBufferData.geometries[r].indexBuffer,l=a.geometries[r].vertexBuffer,u=a.geometries[r].indexBuffer,c=I.verticesFor(r),d=I.indicesFor(r);Object(i.d)(c,d,l,u,s,o,n),s.vertexFrom=c,s.indexFrom=d,I.needMore(r,s.vertexCount,s.indexCount),this.tileDisplayData.displayList.addToList(s)}}if(0!==s){const e=r[t];for(let t=0;t<s;t++){const s=e.displayRecords[t],r=s.geometryType,o=this.tileBufferData.geometries[r].vertexBuffer,n=this.tileBufferData.geometries[r].indexBuffer,l=a.geometries[r].vertexBuffer,u=a.geometries[r].indexBuffer,c=I.verticesFor(r),d=I.indicesFor(r);Object(i.d)(c,d,l,u,s,o,n),s.vertexFrom=c,s.indexFrom=d,I.needMore(r,s.vertexCount,s.indexCount),this.tileDisplayData.displayList.addToList(s)}}for(let o=t;o<r.length;o++){const n=r[o];for(let r=o===t?s:0;r<n.displayRecords.length;r++){const t=n.displayRecords[r],s=t.geometryType,o=e.addOrUpdate.tileBufferData.geometries[s],l=o.vertexBuffer,u=o.indexBuffer,c=a.geometries[s].vertexBuffer,d=a.geometries[s].indexBuffer,h=I.verticesFor(s),f=I.indicesFor(s);Object(i.d)(h,f,c,d,t,l,u),t.vertexFrom=h,t.indexFrom=f,I.needMore(s,t.vertexCount,t.indexCount),this.tileDisplayData.displayList.addToList(t)}this.tileDisplayData.hasRegistry&&this.tileDisplayData.displayObjectRegistry.set(n.id,n),this.tileDisplayData.displayObjects.push(n)}this.tileBufferData=a}getStrides(){const e=[];for(let t=0;t<this.tileBufferData.geometries.length;++t){const s=this.tileBufferData.geometries[t];e[t]={};for(const i in s.vertexBuffer)e[t][i]=s.vertexBuffer[i].stride}return e}clone(){const e=new B;return e.tileBufferData=this.tileBufferData.clone(),e.tileDisplayData=this.tileDisplayData.clone(),e}_guessSize(){const{displayObjects:e}=this.tileDisplayData,t=Math.min(e.length,4);let s=0;for(let i=0;i<t;i++)s=Math.max(s,e[i].displayRecords.length);return 2*(12*e.length+e.length*s*40)}serialize(){const e=this.tileBufferData.serialize(),t=this.tileBufferData.getBuffers(),s=this.tileDisplayData.serialize(new T.a(Int32Array,this._guessSize())).buffer();return t.push(s),{result:{displayData:s,bufferData:e},transferList:t}}static decode(e){const t=R.a.deserializeDisplayObjects(e),s={};for(const t in e.vertexBuffersMap)s[t]=w.a.decode(e.vertexBuffersMap[t]);return B.fromMeshData({displayObjects:t,vertexBuffersMap:s})}static fromMeshData(e){const t=new B,s=new D,i=new n;s.displayObjects=e.displayObjects;for(const t in e.vertexBuffersMap){const s=e.vertexBuffersMap[t];i.geometries[t].indexBuffer=s.indexBuffer,i.geometries[t].vertexBuffer=s.namedBuffers}return t.tileDisplayData=s,t.tileBufferData=i,t}static bind(e,t){const s=new B;return s.tileDisplayData=e,s.tileBufferData=t,s}static create(e,t){const s=new B;s.tileDisplayData=new D,s.tileDisplayData.displayObjects=e;const i=[0,0,0,0,0],r=[0,0,0,0,0],o=[[],[],[],[],[]];for(const t of e)for(const e of t.displayRecords)o[e.geometryType].push(e),i[e.geometryType]+=e.meshData.vertexCount,r[e.geometryType]+=e.meshData.indexData.length;const l=new n,u=function(e){return[e.fill||{},e.line||{},e.icon||{},e.text||{},e.label||{}]}(t);for(let e=0;e<5;e++){const t=new Uint32Array(r[e]),s=E(u[e],i[e]);a.a.writeAllMeshDataToBuffers(o[e],s,t),l.geometries[e]={indexBuffer:t,vertexBuffer:s}}return s.tileBufferData=l,s}static _align(e,t){const s=e%t;return 0===s?e:e+(t-s)}static _computeVertexAlignment(e){let t=!1,s=!1;for(const i of e)i%4==2?t=!0:i%4!=0&&(s=!0);return s?4:t?2:1}}},527:function(e,t,s){"use strict";var i=s(8);t.a=class{constructor(e=Number.POSITIVE_INFINITY){this.size=0,this._start=0,this.maxSize=e,this._buffer=isFinite(e)?new Array(e):[]}get entries(){return this._buffer}enqueue(e){if(this.size===this.maxSize){const t=this._buffer[this._start];return this._buffer[this._start]=e,this._start=(this._start+1)%this.maxSize,t}return isFinite(this.maxSize)?this._buffer[(this._start+this.size++)%this.maxSize]=e:this._buffer[this._start+this.size++]=e,null}dequeue(){if(0===this.size)return null;const e=this._buffer[this._start];return this._buffer[this._start]=null,this.size--,this._start=(this._start+1)%this.maxSize,e}clear(){for(;Object(i.h)(this.dequeue()););}}},540:function(e,t,s){"use strict";s.d(t,"a",(function(){return F})),s.d(t,"b",(function(){return L}));var i=s(23),r=s(396),o=s(49),n=s(69),a=s(110),l=s(45),u=s(455),c=s(403),d=(s(495),s(464)),h=(s(148),s(0)),f=(s(4),s(9),s(5),s(6),s(1)),p=s(2),y=(s(3),s(10),s(11),s(18));let b=class extends y.a{constructor(){super(...arguments),this.SCENEVIEW_HITTEST_RETURN_INTERSECTOR=!1,this.SCENEVIEW_LOCKING_LOG=!1,this.HIGHLIGHTS_GRID_OPTIMIZATION_DISABLED=!1,this.HIGHLIGHTS_PROFILE_TO_CONSOLE=!1,this.DECONFLICTOR_SHOW_VISIBLE=!1,this.DECONFLICTOR_SHOW_INVISIBLE=!1,this.DECONFLICTOR_SHOW_GRID=!1,this.LABELS_SHOW_BORDER=!1,this.OVERLAY_DRAW_DEBUG_TEXTURE=!1,this.OVERLAY_SHOW_CENTER=!1,this.SHOW_POI=!1,this.TERRAIN_DEBUG_POPUP=!1,this.TESTS_DISABLE_UPDATE_THRESHOLDS=!1,this.DISABLE_DECONFLICTOR_VISIBILITY_OFFSET=!1,this.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES=!1,this.DRAW_MESH_GEOMETRY_NORMALS=!1,this.FEATURE_TILE_FETCH_SHOW_TILES=!1,this.FEATURE_TILE_TREE_SHOW_TILES=!1,this.I3S_TREE_SHOW_TILES=!1,this.I3S_SHOW_MODIFICATIONS=!1,this.ENABLE_PROFILE_DEPTH_RANGE=!1,this.DISABLE_FAST_UPDATES=!1,this.LOD_INSTANCE_RENDERER_DISABLE_UPDATES=!1,this.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL=!1,this.EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES=!1}};Object(h.a)([Object(f.b)()],b.prototype,"SCENEVIEW_HITTEST_RETURN_INTERSECTOR",void 0),Object(h.a)([Object(f.b)()],b.prototype,"SCENEVIEW_LOCKING_LOG",void 0),Object(h.a)([Object(f.b)()],b.prototype,"HIGHLIGHTS_GRID_OPTIMIZATION_DISABLED",void 0),Object(h.a)([Object(f.b)()],b.prototype,"HIGHLIGHTS_PROFILE_TO_CONSOLE",void 0),Object(h.a)([Object(f.b)()],b.prototype,"DECONFLICTOR_SHOW_VISIBLE",void 0),Object(h.a)([Object(f.b)()],b.prototype,"DECONFLICTOR_SHOW_INVISIBLE",void 0),Object(h.a)([Object(f.b)()],b.prototype,"DECONFLICTOR_SHOW_GRID",void 0),Object(h.a)([Object(f.b)()],b.prototype,"LABELS_SHOW_BORDER",void 0),Object(h.a)([Object(f.b)()],b.prototype,"OVERLAY_DRAW_DEBUG_TEXTURE",void 0),Object(h.a)([Object(f.b)()],b.prototype,"OVERLAY_SHOW_CENTER",void 0),Object(h.a)([Object(f.b)()],b.prototype,"SHOW_POI",void 0),Object(h.a)([Object(f.b)()],b.prototype,"TERRAIN_DEBUG_POPUP",void 0),Object(h.a)([Object(f.b)()],b.prototype,"TESTS_DISABLE_UPDATE_THRESHOLDS",void 0),Object(h.a)([Object(f.b)()],b.prototype,"DISABLE_DECONFLICTOR_VISIBILITY_OFFSET",void 0),Object(h.a)([Object(f.b)()],b.prototype,"DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES",void 0),Object(h.a)([Object(f.b)()],b.prototype,"DRAW_MESH_GEOMETRY_NORMALS",void 0),Object(h.a)([Object(f.b)()],b.prototype,"FEATURE_TILE_FETCH_SHOW_TILES",void 0),Object(h.a)([Object(f.b)()],b.prototype,"FEATURE_TILE_TREE_SHOW_TILES",void 0),Object(h.a)([Object(f.b)()],b.prototype,"I3S_TREE_SHOW_TILES",void 0),Object(h.a)([Object(f.b)()],b.prototype,"I3S_SHOW_MODIFICATIONS",void 0),Object(h.a)([Object(f.b)()],b.prototype,"ENABLE_PROFILE_DEPTH_RANGE",void 0),Object(h.a)([Object(f.b)()],b.prototype,"DISABLE_FAST_UPDATES",void 0),Object(h.a)([Object(f.b)()],b.prototype,"LOD_INSTANCE_RENDERER_DISABLE_UPDATES",void 0),Object(h.a)([Object(f.b)()],b.prototype,"LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL",void 0),Object(h.a)([Object(f.b)()],b.prototype,"EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES",void 0),b=Object(h.a)([Object(p.a)("esri.views.3d.support.DebugFlags")],b);var _;new b;function m(e){return null!=e}function x(e){return"number"==typeof e}function v(e){return"string"==typeof e}function g(e,t){e&&e.push(t)}function O(e,t,s,i,r){const o=e.minSize,n=e.maxSize;if(e.expression)return g(r,"Could not convert size info: expression not supported"),!1;if(e.useSymbolValue){const e=i.symbolSize[s];return t.minSize[s]=e,t.maxSize[s]=e,t.offset[s]=t.minSize[s],t.factor[s]=0,t.type[s]=1,!0}if(m(e.field))return m(e.stops)?2===e.stops.length&&x(e.stops[0].size)&&x(e.stops[1].size)?(D(e.stops[0].size,e.stops[1].size,e.stops[0].value,e.stops[1].value,t,s),t.type[s]=1,!0):(g(r,"Could not convert size info: stops only supported with 2 elements"),!1):x(o)&&x(n)&&m(e.minDataValue)&&m(e.maxDataValue)?(D(o,n,e.minDataValue,e.maxDataValue,t,s),t.type[s]=1,!0):null!=c.a[e.valueUnit]?(t.minSize[s]=-1/0,t.maxSize[s]=1/0,t.offset[s]=0,t.factor[s]=1/c.a[e.valueUnit],t.type[s]=1,!0):"unknown"===e.valueUnit?(g(r,"Could not convert size info: proportional size not supported"),!1):(g(r,"Could not convert size info: scale-dependent size not supported"),!1);if(!m(e.field)){if(e.stops&&e.stops[0]&&x(e.stops[0].size))return t.minSize[s]=e.stops[0].size,t.maxSize[s]=e.stops[0].size,t.offset[s]=t.minSize[s],t.factor[s]=0,t.type[s]=1,!0;if(x(o))return t.minSize[s]=o,t.maxSize[s]=o,t.offset[s]=o,t.factor[s]=0,t.type[s]=1,!0}return g(r,"Could not convert size info: unsupported variant of sizeInfo"),!1}function D(e,t,s,i,r,o){const n=Math.abs(i-s)>0?(t-e)/(i-s):0;r.minSize[o]=n>0?e:t,r.maxSize[o]=n>0?t:e,r.offset[o]=e-s*n,r.factor[o]=n}function T(e,t,s){e[4*t+0]=s.r/255,e[4*t+1]=s.g/255,e[4*t+2]=s.b/255,e[4*t+3]=s.a}function R(e,t,s){const i=2===s&&"arithmetic"===e.rotationType;t.offset[s]=i?90:0,t.factor[s]=i?-1:1,t.type[s]=1}function w(e,t,s){if(!e)return null;const i=!t.supportedTypes||!!t.supportedTypes.size,r=!t.supportedTypes||!!t.supportedTypes.color,n=!t.supportedTypes||!!t.supportedTypes.rotation,a=!!t.supportedTypes&&!!t.supportedTypes.opacity,l=e.reduce((e,l)=>{if(!e)return e;if(l.valueExpression)return g(s,"Could not convert visual variables: arcade expressions not supported"),null;switch(l.type){case"size":return i?function(e,t,s,i){if(e.normalizationField||e.valueRepresentation)return g(i,"Could not convert size info: unsupported property"),null;if(null!=(r=e.field)&&!v(r))return g(i,"Could not convert size info: field is not a string"),null;var r;if(t.size){if(e.field)if(t.size.field){if(e.field!==t.size.field)return g(i,"Could not convert size info: multiple fields in use"),null}else t.size.field=e.field}else t.size={field:e.field,minSize:[0,0,0],maxSize:[0,0,0],offset:[0,0,0],factor:[0,0,0],type:[0,0,0]};let o;switch(e.axis){case"width":return o=O(e,t.size,0,s,i),o?t:null;case"height":return o=O(e,t.size,2,s,i),o?t:null;case"depth":return o=O(e,t.size,1,s,i),o?t:null;case"width-and-depth":return o=O(e,t.size,0,s,i),o&&O(e,t.size,1,s,i),o?t:null;case null:case void 0:case"all":return o=O(e,t.size,0,s,i),o=o&&O(e,t.size,1,s,i),o=o&&O(e,t.size,2,s,i),o?t:null;default:return g(i,`Could not convert size info: unknown axis "${e.axis}""`),null}}(l,e,t,s):e;case"color":return r?function(e,t,s){if(e.normalizationField)return g(s,"Could not convert color info: unsupported property"),null;if(v(e.field)){if(!e.stops)return g(s,"Could not convert color info: missing stops or colors"),null;{if(e.stops.length>8)return g(s,"Could not convert color info: too many color stops"),null;t.color={field:e.field,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};const i=e.stops;for(let e=0;e<8;++e){const s=i[Math.min(e,i.length-1)];t.color.values[e]=s.value,T(t.color.colors,e,s.color)}}}else{if(!(e.stops&&e.stops.length>=0))return g(s,"Could not convert color info: no field and no colors/stops"),null;{const s=e.stops&&e.stops.length>=0&&e.stops[0].color;t.color={field:null,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};for(let e=0;e<8;e++)t.color.values[e]=1/0,T(t.color.colors,e,s)}}return t}(l,e,s):e;case"opacity":return a?function(e,t,s){if(e.normalizationField)return g(s,"Could not convert opacity info: unsupported property"),null;if(v(e.field)){if(!e.stops)return g(s,"Could not convert opacity info: missing stops or opacities"),null;{if(e.stops.length>8)return g(s,"Could not convert opacity info: too many opacity stops"),null;t.opacity={field:e.field,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0]};const i=e.stops;for(let e=0;e<8;++e){const s=i[Math.min(e,i.length-1)];t.opacity.values[e]=s.value,t.opacity.opacityValues[e]=s.opacity}}}else{if(!(e.stops&&e.stops.length>=0))return g(s,"Could not convert opacity info: no field and no opacities/stops"),null;{const s=e.stops&&e.stops.length>=0&&e.stops[0].opacity;t.opacity={field:null,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0]};for(let e=0;e<8;e++)t.opacity.values[e]=1/0,t.opacity.opacityValues[e]=s}}return t}(l,e,s):null;case"rotation":return n?function(e,t,s){if(!v(e.field))return g(s,"Could not convert rotation info: field is not a string"),null;if(t.rotation){if(e.field)if(t.rotation.field){if(e.field!==t.rotation.field)return g(s,"Could not convert rotation info: multiple fields in use"),null}else t.rotation.field=e.field}else t.rotation={field:e.field,offset:[0,0,0],factor:[1,1,1],type:[0,0,0]};switch(e.axis){case"tilt":return R(e,t.rotation,0),t;case"roll":return R(e,t.rotation,1),t;case null:case void 0:case"heading":return R(e,t.rotation,2),t;default:return g(s,`Could not convert rotation info: unknown axis "${e.axis}""`),null}}(l,e,s):e;default:return Object(o.a)(l),null}},{size:null,color:null,opacity:null,rotation:null});return!(e.length>0&&l)||l.size||l.color||l.opacity||l.rotation?l&&l.size&&!function(e,t,s){for(let s=0;s<3;++s){let i=t.unitInMeters;1===e.type[s]&&(i*=t.modelSize[s],e.type[s]=2),e.minSize[s]=e.minSize[s]/i,e.maxSize[s]=e.maxSize[s]/i,e.offset[s]=e.offset[s]/i,e.factor[s]=e.factor[s]/i}let i;if(0!==e.type[0])i=0;else if(0!==e.type[1])i=1;else{if(0===e.type[2])return g(s,"No size axis contains a valid size or scale"),!1;i=2}for(let t=0;t<3;++t)0===e.type[t]&&(e.minSize[t]=e.minSize[i],e.maxSize[t]=e.maxSize[i],e.offset[t]=e.offset[i],e.factor[t]=e.factor[i],e.type[t]=e.type[i]);return!0}(l.size,t,s)?null:l:null}!function(e){const t=Object(d.b)(),s=Object(a.e)();e.evaluateModelTransform=function(e,i,r){if(!e.vvSizeEnabled)return r;Object(u.c)(t,r);const o=e.vvSymbolRotationMatrix;Object(u.d)(j,o[0],o[1],o[2],0,o[3],o[4],o[5],0,o[6],o[7],o[8],0,0,0,0,1),Object(u.j)(t,t,j);for(let t=0;t<3;++t){const r=e.vvSizeOffset[t]+i[0]*e.vvSizeFactor[t];s[t]=Object(n.c)(r,e.vvSizeMinSize[t],e.vvSizeMaxSize[t])}return Object(u.n)(t,t,s),Object(u.o)(t,t,e.vvSymbolAnchor),t},e.evaluateModelTransformScale=function(e,t,s){if(!t.vvSizeEnabled)return Object(l.r)(e,1,1,1);for(let i=0;i<3;++i){const r=t.vvSizeOffset[i]+s[0]*t.vvSizeFactor[i];e[i]=Object(n.c)(r,t.vvSizeMinSize[i],t.vvSizeMaxSize[i])}return e}}(_||(_={}));const j=Object(d.b)();_.evaluateModelTransform,_.evaluateModelTransformScale;var I=s(397),E=s(410),B=s(474);function L(e,t){if(!e||!t)return e;switch(t){case"radius":case"distance":return 2*e;case"diameter":case"width":return e;case"area":return Math.sqrt(e)}return e}function S(e){return e.map(e=>{return{value:(t=e).value,size:Object(i.j)(t.size)};var t})}function z(e){if("string"==typeof e||"number"==typeof e)return Object(i.j)(e);const t=e;return{type:"size",expression:t.expression,stops:S(t.stops)}}const C=e=>{const t=[],s=[],o=S(e),n=o.length;for(let e=0;e<6;e++){const a=o[Math.min(e,n-1)];t.push(a.value),s.push(null==a.size?r.p:Object(i.h)(a.size))}return{values:new Float32Array(t),sizes:new Float32Array(s)}};function F(e){const t=e&&e.length>0?{}:null,s=t?{}:null;if(!t)return{vvFields:t,vvRanges:s};for(const i of e){const e=i.type;if(i.field&&(t[e]=i.field),"size"===e){s.size||(s.size={});const e=i;switch(Object(B.a)(e)){case I.e.SIZE_MINMAX_VALUE:s.size.minMaxValue={minDataValue:e.minDataValue,maxDataValue:e.maxDataValue,minSize:z(e.minSize),maxSize:z(e.maxSize)};break;case I.e.SIZE_SCALE_STOPS:s.size.scaleStops={stops:S(e.stops)};break;case I.e.SIZE_FIELD_STOPS:if(e.levels){const t={};for(const s in e.levels)t[s]=C(e.levels[s]);s.size.fieldStops={type:"level-dependent",levels:t}}else s.size.fieldStops={type:"static",...C(e.stops)};break;case I.e.SIZE_UNIT_VALUE:s.size.unitValue={unit:e.valueUnit,valueRepresentation:e.valueRepresentation}}}else if("color"===e){const e=w([i],{modelSize:null,symbolSize:null,unitInMeters:1,transformation:null});if(!e)continue;s.color=e.color;for(let e=0;e<32;e+=4)Object(E.b)(s.color.colors,e,!0)}else if("opacity"===e)s.opacity=M(i);else if("rotation"===e){const e=i;s.rotation={type:e.rotationType}}}return{vvFields:t,vvRanges:s}}function M(e){const t={values:[0,0,0,0,0,0,0,0],opacities:[0,0,0,0,0,0,0,0]};if("string"==typeof e.field){if(!e.stops)return null;{if(e.stops.length>8)return null;const s=e.stops;for(let e=0;e<8;++e){const i=s[Math.min(e,s.length-1)];t.values[e]=i.value,t.opacities[e]=i.opacity}}}else{if(!(e.stops&&e.stops.length>=0))return null;{const s=e.stops&&e.stops.length>=0&&e.stops[0].opacity;for(let e=0;e<8;e++)t.values[e]=1/0,t.opacities[e]=s}}return t}},555:function(e,t,s){"use strict";s.d(t,"a",(function(){return C}));var i=s(7),r=s(259),o=s(224),n=s(517),a=s(513),l=s(4),u=s(8),c=s(5),d=s(14),h=s(396),f=(s(404),s(405),s(406)),p=(s(407),s(408),s(409)),y=(s(411),s(398)),b=s(494);const _=c.a.getLogger("esri.views.2d.engine.webgl.AttributeStoreView"),m=Object(b.b)(b.a,_),x=e=>2147483647&e;let v=!1;class g{constructor(e,t,s){this._texture=null,this._lastTexture=null,this._fbos={},this.texelSize=4;const{buffer:i,pixelType:r,textureOnly:o}=e,n=Object(y.i)(r);this.shared=s,this.pixelType=r,this.size=t,this.textureOnly=o,o||(this.data=new n(Object(u.m)(i))),this._resetRange()}destroy(){Object(u.a)(this._texture,e=>e.dispose());for(const e in this._fbos)Object(u.a)(this._fbos[e],t=>{"0"===e&&t.detachColorTexture(),t.dispose()}),this._fbos[e]=null;this._texture=null}get _textureDesc(){return{target:3553,wrapMode:33071,pixelFormat:6408,dataType:this.pixelType,samplingMode:9728,width:this.size,height:this.size}}setData(e,t,s){const i=x(e),r=Object(u.m)(this.data),o=i*this.texelSize+t;!r||o>=r.length?Object(l.a)("esri-2d-debug")&&!v&&(_.error(new d.a("mapview-attributeStore","Attempted to set out of bounds index")),v=!0):(r[o]=s,this.dirtyStart=Math.min(this.dirtyStart,i),this.dirtyEnd=Math.max(this.dirtyEnd,i))}getData(e,t){if(Object(u.g)(this.data))return null;const s=x(e)*this.texelSize+t;return!this.data||s>=this.data.length?(Object(l.a)("esri-2d-debug")&&!v&&(_.error(new d.a("mapview-attributeStore","Attempted to read out of bounds index")),v=!0),null):this.data[s]}getTexture(e){return Object(u.n)(this._texture,()=>this._initTexture(e))}getFBO(e,t=0){if(Object(u.g)(this._fbos[t])){const s={colorTarget:0,depthStencilTarget:0},i=0===t?this.getTexture(e):this._textureDesc;this._fbos[t]=new p.a(e,s,i)}return this._fbos[t]}get locked(){return!(5121!==this.pixelType||!this.shared||this.textureOnly||!Object(l.a)("esri-atomics")||!this.data)&&1===Atomics.load(this.data,0)}updateTexture(e){if(!this.locked)try{const t=this.dirtyStart,s=this.dirtyEnd;if(t>s)return;this._resetRange();const i=Object(u.m)(this.data).buffer,r=this.getTexture(e),o=4,n=(t-t%this.size)/this.size,a=(s-s%this.size)/this.size,l=n,c=this.size,h=a,f=n*this.size*o,p=(c+h*this.size)*o-f,b=Object(y.i)(this.pixelType),m=b.BYTES_PER_ELEMENT;try{new b(i,f*m,p)}catch(e){console.debug(e)}const x=new b(i,f*m,p),v=this.size,g=h-l+1;if(g>this.size)return void _.error(new d.a("mapview-webgl","Out-of-bounds index when updating AttributeData"));r.updateData(0,0,l,v,g,x)}catch(e){console.debug(e)}}update(e){const{data:t,start:s,end:i}=e;if(Object(u.h)(t)){const i=this.data,r=s*this.texelSize;for(let s=0;s<t.length;s++){const o=1<<s%this.texelSize;e.layout&o&&(i[r+s]=t[s])}}this.dirtyStart=Math.min(this.dirtyStart,s),this.dirtyEnd=Math.max(this.dirtyEnd,i)}resize(e,t){const s=this.size;if(this.size=t,this.textureOnly)return void(s!==this.size&&(this._lastTexture=this._texture,this._texture=null));const i=Object(y.i)(this.pixelType);this.destroy(),this.data=new i(Object(u.m)(e.buffer))}_resetRange(){this.dirtyStart=2147483647,this.dirtyEnd=0}_initTexture(e){const t=new f.a(e,this._textureDesc,Object(u.n)(this.data,void 0));if(Object(u.h)(this._lastTexture)&&this._fbos[0]){const s=this._lastTexture.descriptor.width,i=this._lastTexture.descriptor.height,r=this._lastTexture.descriptor.dataType,o=this._lastTexture.descriptor.pixelFormat,n=this.getFBO(e),a=Object(y.j)(r),l=new(Object(y.i)(r))(new ArrayBuffer(s*i*a*this.texelSize)),u=e.getBoundFramebufferObject(),{x:c,y:d,width:h,height:f}=e.getViewport();e.bindFramebuffer(n),n.readPixels(0,0,s,i,o,r,l),t.updateData(0,0,0,2*s,i/2,l),e.setViewport(c,d,h,f),e.bindFramebuffer(u)}return this.destroy(),this._texture=t,this._texture}}class O{constructor(){this._initialized=!1,this._forceNextUpload=!1,this._locked=!1}initialize(e){const{blocks:t,shared:s,size:i}=e;if(this.shared=s,this.size=i,m("Initializing AttributeStoreView",e),Object(u.g)(this._data))this._data=Object(u.j)(t,e=>new g(e,i,s));else for(let e=0;e<this._data.length;e++){const r=this._data[e],o=t[e];Object(u.h)(o)&&(Object(u.g)(r)?this._data[e]=new g(o,i,s):r.resize(o,i))}this._initialized=!0}destroy(){Object(u.a)(this._data,e=>Object(u.j)(e,e=>e.destroy())),Object(u.a)(this._defaultTexture,e=>e.dispose())}getBlock(e){return Object(u.g)(this._data)?null:this._data[e]}setLabelMinZoom(e,t){this.setData(e,0,1,t)}getLabelMinZoom(e){return this.getData(e,0,1,255)}getFilterFlags(e){return this.getData(e,0,0,0)}getVVSize(e){return this.getData(e,h.b,0,0)}getData(e,t,s,i){if(!this._data)return 0;const r=Object(u.m)(this._data)[t];if(Object(u.g)(r))return 0;const o=r.getData(e,s);return Object(u.h)(o)?o:i}setData(e,t,s,i){const r=Object(u.m)(this._data)[t];Object(u.m)(r).setData(e,s,i)}lockTextureUpload(){this._locked=!0}unlockTextureUpload(){this._locked=!1}forceTextureUpload(){this._forceNextUpload=!0}async requestUpdate(e){if(this._pendingAttributeUpdate)return void _.error(new d.a("mapview-webgl","Tried to update attribute data with a pending update"));const t=Object(i.g)();return m("AttributeStoreView Update Requested",e),this._pendingAttributeUpdate={data:e,resolver:t},t.promise}update(){if(this._initialized&&Object(u.h)(this._pendingAttributeUpdate)){const{data:e,resolver:t}=this._pendingAttributeUpdate,s=Object(u.m)(this._data);for(let t=0;t<e.blocks.length;t++){const i=e.blocks[t],r=s[t];Object(u.a)(r,e=>Object(u.a)(i,s=>{m("Updating block "+t,s),e.update(s)}))}this._pendingAttributeUpdate=null,t()}}bindTextures(e){this.update();const t=this._getDefaultTexture(e);if(!this._initialized)return e.bindTexture(t,h.s),e.bindTexture(t,h.t),e.bindTexture(t,h.u),void e.bindTexture(t,h.v);const s=Object(u.m)(this._data);this._locked&&!this._forceNextUpload||(Object(u.e)(s,t=>t.updateTexture(e)),this._forceNextUpload=!1),e.bindTexture(Object(u.k)(s[0],t,t=>t.getTexture(e)),h.s),e.bindTexture(Object(u.k)(s[1],t,t=>t.getTexture(e)),h.t),e.bindTexture(Object(u.k)(s[2],t,t=>t.getTexture(e)),h.u),e.bindTexture(Object(u.k)(s[3],t,t=>t.getTexture(e)),h.v)}_getDefaultTexture(e){if(Object(u.g)(this._defaultTexture)){const t={wrapMode:33071,pixelFormat:6408,dataType:5121,samplingMode:9728,width:1,height:1};this._defaultTexture=new f.a(e,t,new Uint8Array(4))}return this._defaultTexture}}var D=s(483),T=s(35),R=s(23),w=s(50),j=s(403),I=s(539);function E(e,t){const s=t.length;if(e<t[0].value||1===s)return t[0].size;for(let i=1;i<s;i++)if(e<t[i].value){const s=(e-t[i-1].value)/(t[i].value-t[i-1].value);return t[i-1].size+s*(t[i].size-t[i-1].size)}return t[s-1].size}function B(e,t,s=0){if(Object(u.g)(t))return e[s+0]=0,e[s+1]=0,e[s+2]=0,void(e[s+3]=0);const{r:i,g:r,b:o,a:n}=t;e[s+0]=i*n/255,e[s+1]=r*n/255,e[s+2]=o*n/255,e[s+3]=n}const L=(e,t,s)=>{const i=16*s;for(let s=i,r=0;s<Math.min(i+16,e.length);s++,r++)e[s]=t[r]},S=Object(I.b)();class z{constructor(){this.symbolLevels=[],this.vvColorValues=new Float32Array(8),this.vvColors=new Float32Array(32),this.vvOpacityValues=new Float32Array(8),this.vvOpacities=new Float32Array(8),this.vvSizeMinMaxValue=new Float32Array(4),this.ddColors=new Float32Array(32),this.ddBackgroundColor=new Float32Array(4),this.ddActiveDots=new Float32Array(8),this.insideEffect=new Float32Array(16*h.o),this.insideOpacity=1,this.outsideEffect=new Float32Array(16*h.o),this.outsideOpacity=1,this.effectCount=0,this._vvMaterialParameters={vvSizeEnabled:!1,vvColorEnabled:!1,vvRotationEnabled:!1,vvRotationType:"geographic",vvOpacityEnabled:!1},this._buf0=new Float32Array(2),this._buf1=new Float32Array(2),this.symbolLevels.push(0);for(let e=0;e<h.o;e++)L(this.insideEffect,S,e),L(this.outsideEffect,S,e)}get insideOpacities(){return this._buf0[0]=1,this._buf0[1]=this.insideOpacity,this._buf0}get outsideOpacities(){return this._buf1[0]=0,this._buf1[1]=this.outsideOpacity,this._buf1}getSizeVVFieldStops(e){const t=this._vvSizeFieldStops;switch(t.type){case"static":return t;case"level-dependent":return Object(u.n)(t.levels[e],()=>{let s=1/0,i=0;for(const r in t.levels){const t=parseFloat(r),o=Math.abs(e-t);o<s&&(s=o,i=t)}if(s===1/0)return{sizes:new Float32Array([0,0,0,0,0,0]),values:new Float32Array([0,0,0,0,0,0])};const r=e-i,o=Math.pow(2,r/2),n=Object(u.m)(t.levels[i]),a=new Float32Array(n.values);return a[2]*=o,a[3]*=o,{sizes:Object(u.m)(n.sizes),values:a}})}}get vvMaterialParameters(){return this._vvMaterialParameters}update(e){Object(u.h)(this._vvInfo)&&this._updateVisualVariables(this._vvInfo.vvRanges,e)}setInfo(e,t,s){switch(Object(u.h)(s)?(s.forEach((e,t)=>this._updateEffects(t,e)),this.effectCount=s.length):this.effectCount=0,this._vvInfo=t,e.type){case"dot-density":this._updateDotDensityInfo(e)}}getVariation(){return{ddDotBlending:this.ddDotBlending,outsideLabelsVisible:this.outsideLabelsVisible,effectCount:this.effectCount,oesTextureFloat:Object(l.a)("esri-webgl-texture-float")}}getVariationHash(){return(this.ddDotBlending?1:0)|(this.outsideLabelsVisible?1:0)<<1|this.effectCount<<2}_updateEffects(e,t){const s=e+1;if(Object(u.h)(t)&&t.filter&&t.filter.enabled){this.outsideLabelsVisible=t.excludedLabelsVisible;const{parsedIncludedEffect:e,parsedExcludedEffect:i}=t;Object(u.h)(e)?(L(this.insideEffect,e.getColorMatrix(),s),this.insideOpacity=e.getOpacity()):(L(this.insideEffect,S,s),this.insideOpacity=1),Object(u.h)(i)?(L(this.outsideEffect,i.getColorMatrix(),s),this.outsideOpacity=i.getOpacity()):(L(this.outsideEffect,S,s),this.outsideOpacity=1)}else L(this.insideEffect,S,s),L(this.outsideEffect,S,s),this.insideOpacity=1,this.outsideOpacity=1}_updateVisualVariables(e,t){const s=this._vvMaterialParameters;if(s.vvOpacityEnabled=!1,s.vvSizeEnabled=!1,s.vvColorEnabled=!1,s.vvRotationEnabled=!1,!e)return;const i=e.size;if(i){if(s.vvSizeEnabled=!0,i.minMaxValue){const e=i.minMaxValue;let s,r;if(Object(y.m)(e.minSize)&&Object(y.m)(e.maxSize))if(Object(y.n)(e.minSize)&&Object(y.n)(e.maxSize))s=Object(R.h)(e.minSize),r=Object(R.h)(e.maxSize);else{const i=t.scale;s=Object(R.h)(E(i,e.minSize.stops)),r=Object(R.h)(E(i,e.maxSize.stops))}this.vvSizeMinMaxValue.set([e.minDataValue,e.maxDataValue,s,r])}if(i.scaleStops&&(this.vvSizeScaleStopsValue=Object(R.h)(E(t.scale,i.scaleStops.stops))),i.unitValue){const e=Object(w.c)(t.spatialReference)/j.a[i.unitValue.unit];this.vvSizeUnitValueToPixelsRatio=e/t.resolution}i.fieldStops&&(this._vvSizeFieldStops=i.fieldStops)}const r=e.color;r&&(s.vvColorEnabled=!0,this.vvColorValues.set(r.values),this.vvColors.set(r.colors));const o=e.opacity;o&&(s.vvOpacityEnabled=!0,this.vvOpacityValues.set(o.values),this.vvOpacities.set(o.opacities));const n=e.rotation;n&&(s.vvRotationEnabled=!0,s.vvRotationType=n.type)}_updateDotDensityInfo(e){const t=e.attributes;this.ddDotValue=e.dotValue,this.ddDotScale=e.referenceScale,this.ddDotSize=e.dotSize,this.ddDotBlending=e.dotBlendingEnabled,this.ddSeed=e.seed;for(let e=0;e<h.g;e++){const s=e>=t.length?new T.a([0,0,0,0]):t[e].color;B(this.ddColors,s,4*e)}for(let t=0;t<8;t++)this.ddActiveDots[t]=t<e.attributes.length?1:0;B(this.ddBackgroundColor,e.backgroundColor)}}class C extends D.a{constructor(e){super(e),this._rendererInfo=new z,this._materialItemsRequestQueue=new o.a,this.attributeView=new O}destroy(){this.removeAllChildren(),this.children.forEach(e=>e.destroy()),this.attributeView.destroy(),this._materialItemsRequestQueue.clear()}setRendererInfo(e,t,s){this._rendererInfo.setInfo(e,t,s),this.requestRender()}async getMaterialItems(e,t){if(!e||0===e.length)return null;const s=Object(i.g)();return this._materialItemsRequestQueue.push({items:e,abortOptions:t,resolver:s}),this.requestRender(),s.promise}onTileData(e,t){if(t.addOrUpdate&&"tileDisplayData"in t.addOrUpdate)e.setData(t);else{const s=t.addOrUpdate&&n.a.decode(t.addOrUpdate),i={...t,addOrUpdate:s};e.setData(i)}this.contains(e)||this.addChild(e),this.requestRender()}onTileError(e){e.clear(),this.contains(e)||this.addChild(e)}doRender(e){if(e.context.capabilities.textureFloat,e.context.capabilities.vao,this._materialItemsRequestQueue.length>0){let t=this._materialItemsRequestQueue.pop();for(;t;)this._processMaterialItemRequest(e,t),t=this._materialItemsRequestQueue.pop()}super.doRender(e)}renderChildren(e){for(const t of this.children)t.commitChanges(e);this._rendererInfo.update(e.state),this.attributeView.bindTextures(e.context),super.renderChildren(e)}createTile(e){const t=this._tileInfoView.getTileBounds(Object(r.d)(),e);return new a.a(e,t)}destroyTile(e){this.removeChild(e),e.destroy()}createRenderParams(e){return{...super.createRenderParams(e),rendererInfo:this._rendererInfo,attributeView:this.attributeView}}_processMaterialItemRequest(e,{items:t,abortOptions:s,resolver:r}){const{painter:o,pixelRatio:n}=e,a=t.map(e=>o.textureManager.rasterizeItem(e.symbol,n,e.glyphIds,s));Object(i.a)(a).then(e=>{if(!this.stage)return void r.reject();const s=e.map((e,s)=>({id:t[s].id,mosaicItem:e}));r.resolve(s)},r.reject)}}},730:function(e,t,s){"use strict";var i=s(0),r=(s(4),s(9),s(5),s(6),s(1)),o=s(2),n=(s(3),s(10),s(11),s(112));let a=class extends n.a{constructor(e){super(e),this.tiles=new Map}destroy(){this.tiles.clear(),this.layer=this.layerView=this.tileInfoView=this.tiles=null}get updating(){return this.isUpdating()}acquireTile(e){const t=this.createTile(e);return t.once("isReady",()=>this.notifyChange("updating")),this.tiles.set(e.id,t),t}forceAttributeTextureUpload(){}forEachTile(e){this.tiles.forEach(e)}releaseTile(e){this.tiles.delete(e.key.id),this.disposeTile(e)}isUpdating(){let e=!0;return this.tiles.forEach(t=>{e=e&&t.isReady}),!e}setHighlight(){}invalidateLabels(){}requestUpdate(){this.layerView.requestUpdate()}};Object(i.a)([Object(r.b)()],a.prototype,"layer",void 0),Object(i.a)([Object(r.b)()],a.prototype,"layerView",void 0),Object(i.a)([Object(r.b)()],a.prototype,"tileInfoView",void 0),Object(i.a)([Object(r.b)()],a.prototype,"updating",null),a=Object(i.a)([Object(o.a)("esri.views.2d.layers.features.tileRenderers.BaseTileRenderer")],a);var l=a;t.a=l}}]);